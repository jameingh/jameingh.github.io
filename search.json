[{"title":"选择排序","url":"/2021/02/12/selection-sort/","content":"\n## 排序过程\n\n假如对如下数组排序\n\n![image-20210212212637607](https://gitee.com/jinxin.70/oss/raw/master/uPic/image-20210212212637607_2021_02_12_21_26_37.png)\n\n我们打算从小到大排序\n\n### 第一轮\n\n先找到数组中最小的，是1\n\n![image-20210212212805249](https://gitee.com/jinxin.70/oss/raw/master/uPic/image-20210212212805249_2021_02_12_21_28_05.png)\n\n然后将1和数组中第一个位置上的数交换，这样，1就是最终的位置了\n\n![image-20210212212837283](https://gitee.com/jinxin.70/oss/raw/master/uPic/image-20210212212837283_2021_02_12_21_28_37.png)\n\n### 第二轮\n\n那么1排好了，我们从剩下的数里面找最小的数，是2\n\n![image-20210212212905854](https://gitee.com/jinxin.70/oss/raw/master/uPic/image-20210212212905854_2021_02_12_21_29_06.png)\n\n我们将2和第二个位置上的数交换位置\n\n![image-20210212213045447](https://gitee.com/jinxin.70/oss/raw/master/uPic/image-20210212213045447_2021_02_12_21_30_45.png)\n\n此时，1和2都已经固定好了位置\n\n![image-20210212213108930](https://gitee.com/jinxin.70/oss/raw/master/uPic/image-20210212213108930_2021_02_12_21_31_09.png)\n\n### 第三轮\n\n再从第三个位置往后找最小的数，然后与第三个位置上的数交换位置\n\n![image-20210212213214529](https://gitee.com/jinxin.70/oss/raw/master/uPic/image-20210212213214529_2021_02_12_21_32_14.png)\n\n![image-20210212213226904](https://gitee.com/jinxin.70/oss/raw/master/uPic/image-20210212213226904_2021_02_12_21_32_27.png)\n\n依此类推，找到数组末尾就排好序了\n\n### 第四轮\n\n![image-20210212213300337](https://gitee.com/jinxin.70/oss/raw/master/uPic/image-20210212213300337_2021_02_12_21_33_00.png)\n\n![image-20210212213317201](https://gitee.com/jinxin.70/oss/raw/master/uPic/image-20210212213317201_2021_02_12_21_33_17.png)\n\n### 第五轮\n\n![image-20210212213342282](https://gitee.com/jinxin.70/oss/raw/master/uPic/image-20210212213342282_2021_02_12_21_33_42.png)\n\n![image-20210212213355567](https://gitee.com/jinxin.70/oss/raw/master/uPic/image-20210212213355567_2021_02_12_21_33_55.png)\n\n### 第六轮\n\n![image-20210212213442090](https://gitee.com/jinxin.70/oss/raw/master/uPic/image-20210212213442090_2021_02_12_21_34_42.png)\n\n![image-20210212213453305](https://gitee.com/jinxin.70/oss/raw/master/uPic/image-20210212213453305_2021_02_12_21_34_53.png)\n\n### 第七轮\n\n![image-20210212213512606](https://gitee.com/jinxin.70/oss/raw/master/uPic/image-20210212213512606_2021_02_12_21_35_12.png)\n\n### 第八轮\n\n![image-20210212213535214](https://gitee.com/jinxin.70/oss/raw/master/uPic/image-20210212213535214_2021_02_12_21_35_35.png)\n\n## C++实现\n\n```c++\n#include <iostream>\n\nusing namespace std;\n/**\n * 选择排序\n * @param arr\n * @param n\n */\nvoid selectionSort(int arr[], int n){\n    for (int i = 0; i < n; ++i) {\n        //寻找[1,n)区间里的最小值\n        int minIndex = i;\n        for (int j = i + 1; j < n; ++j) {\n            if(arr[j] < arr[minIndex]){\n                minIndex = j;\n            }\n        }\n        swap(arr[i], arr[minIndex]);\n    }\n}\n\nint main(){\n    int a[10] = {10,9,8,7,6,5,4,3,2,1};\n    selectionSort(a, 10);\n\n    for (int i = 0; i < 10; ++i) {\n        cout<<a[i]<<\" \";\n    }\n    cout<<endl;\n    return 0;\n}\n```\n\n\n\n## 使用模板（范型）编写算法\n\n上面的实现，只能对int数组排序，我们需要对不同的类型排序，所以需要用到模板，有的语言叫范型。\n\n**Student.h**\n\n```c++\n\n#ifndef ALGORITHMCPLUSPLUS_STUDENT_H\n#define ALGORITHMCPLUSPLUS_STUDENT_H\n\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\nstruct Student{\n    string name;\n    int score;\n\n    // 重载小于运算法,定义Student之间的比较方式\n    // 如果分数相等，则按照名字的字母序排序\n    // 如果分数不等，则分数高的靠前\n    bool operator<(const Student& otherStudent){\n        return score != otherStudent.score ?\n               score > otherStudent.score : name < otherStudent.name;\n    }\n\n    // 重载<<符号, 定义Student实例的打印输出方式\n    // * 很多同学看到这里的C++语法, 头就大了, 甚至还有同学表示要重新学习C++语言\n    // * 对于这个课程, 大可不必。C++语言并不是这个课程的重点,\n    // * 大家也完全可以使用自己的方式书写代码, 最终只要能够打印出结果就好了, 比如设置一个成员函数, 叫做show()...\n    // * 推荐大家阅读我在问答区向大家分享的一个学习心得: 【学习心得分享】请大家抓大放小，不要纠结于C++语言的语法细节\n    // * 链接: http://coding.imooc.com/learn/questiondetail/4100.html\n    friend ostream& operator<<(ostream &os, const Student &student){\n\n        os<<\"Student: \"<<student.name<<\" \"<<student.score<<endl;\n        return os;\n    }\n};\n\n#endif //ALGORITHMCPLUSPLUS_STUDENT_H\n```\n\n**main.cpp**\n\n```c++\n#include <iostream>\n\nusing namespace std;\n#include \"Student.h\"\ntemplate<typename T>\n/**\n * 选择排序\n * @param arr\n * @param n\n */\nvoid selectionSort(T arr[], int n){\n    for (int i = 0; i < n; ++i) {\n        //寻找[1,n)区间里的最小值\n        int minIndex = i;\n        for (int j = i + 1; j < n; ++j) {\n            if(arr[j] < arr[minIndex]){\n                minIndex = j;\n            }\n        }\n        swap(arr[i], arr[minIndex]);\n    }\n}\n\nint main(){\n    int a[10] = {10,9,8,7,6,5,4,3,2,1};\n    selectionSort(a, 10);\n\n    for (int i = 0; i < 10; ++i) {\n        cout<<a[i]<<\" \";\n    }\n    cout<<endl;\n\n    float b[4] = {4.4,3.3,2.2,1.1};\n    selectionSort(b, 4);\n    for (int i = 0; i < 4; ++i) {\n        cout<<b[i]<< \" \";\n    }\n    cout<<endl;\n\n    string c[4] = {\"D\",\"C\",\"B\",\"A\"};\n    selectionSort(c,4);\n    for( int i = 0 ; i < 4 ; i ++ )\n        cout<<c[i]<<\" \";\n    cout<<endl;\n\n    Student d[4] = { {\"D\",90} , {\"C\",100} , {\"B\",95} , {\"A\",95} };\n    selectionSort(d,4);\n    for( int i = 0 ; i < 4 ; i ++ )\n        cout<<d[i];\n    cout<<endl;\n    return 0;\n}\n```\n\n## 随机生成算法测试用例（选学）\n\n思考🤔：\n\n我们上面代码的测试用例是硬编码的，我们希望生成自动生成。\n\n**SortTestHelper.h**\n\n```c++\n#ifndef ALGORITHMCPLUSPLUS_SORTTESTHELPER_H\n#define ALGORITHMCPLUSPLUS_SORTTESTHELPER_H\n#include <iostream>\n#include <ctime>\n#include <cassert>\n\nusing namespace std;\n\nnamespace SortTestHelper {\n// 生成有n个元素的随机数组,每个元素的随机范围为[rangeL, rangeR]\n    int *generateRandomArray(int n, int rangeL, int rangeR) {\n\n        assert(rangeL <= rangeR);\n\n        int *arr = new int[n];\n\n        srand(time(NULL));\n        for (int i = 0; i < n; i++)\n            arr[i] = rand() % (rangeR - rangeL + 1) + rangeL;\n        return arr;\n    }\n\n    // 打印arr数组的所有内容\n    template<typename T>\n    void printArray(T arr[], int n) {\n\n        for (int i = 0; i < n; i++)\n            cout << arr[i] << \" \";\n        cout << endl;\n\n        return;\n    }\n  // 判断arr数组是否有序\n    template<typename T>\n    bool isSorted(T arr[], int n) {\n\n        for (int i = 0; i < n - 1; i++)\n            if (arr[i] > arr[i + 1])\n                return false;\n\n        return true;\n    }\n\n    // 测试sort排序算法排序arr数组所得到结果的正确性和算法运行时间\n    // * 使用VS编码的同学, 对于函数指针的写法和调用方法可能和课程中介绍的有所不同;\n    // * 并且不同版本的VS, 其具体语法可能也有差异, 这是因为VS的编译器不完全是按照C++的标准实现的;\n    // * 本课程按照C++11的标准进行书写。对于VS编译器带来的语法差异, 希望同学们可以自己在网上查找相关资料解决;\n    // * 大家也可以在课程的官方QQ群中交流\n    // * 另外, 使用函数指针本身并不是这个课程的重点, 大家也完全可以使用自己的方式书写代码, 最终只要能够测试出自己书写的算法的效率即可\n    // * 推荐大家阅读我在问答区向大家分享的一个学习心得: 【学习心得分享】请大家抓大放小，不要纠结于C++语言的语法细节\n    // * 链接: http://coding.imooc.com/learn/questiondetail/4100.html\n    template<typename T>\n    void testSort(const string &sortName, void (*sort)(T[], int), T arr[], int n) {\n\n        clock_t startTime = clock();\n        sort(arr, n);\n        clock_t endTime = clock();\n\n        assert(isSorted(arr, n));\n        cout << sortName << \" : \" << double(endTime - startTime) / CLOCKS_PER_SEC << \" s\" << endl;\n//CLOCKS_PER_SEC表示每秒运行的时间周期数\n        return;\n    }\n};\n#endif //ALGORITHMCPLUSPLUS_SORTTESTHELPER_H\n```\n\ntestSort函数的入参void (*sort)(T[], int)是对一个函数的声明，其中\n\n- void 是返回值，表示返回void\n\n- *sort是函数指针\n\n- (T[], int)表示参数，T数组和int类型变量表示长度\n\n并且在函数声明上方要对T进行声明，template<typename T>\n\n**main.cpp**\n\n```c++\n#include <iostream>\n#include \"SortTestHelper.h\"\n\nusing namespace std;\n\ntemplate<typename T>\nvoid selectionSort(T arr[], int n){\n\n    for(int i = 0 ; i < n ; i ++){\n\n        int minIndex = i;\n        for( int j = i + 1 ; j < n ; j ++ )\n            if( arr[j] < arr[minIndex] )\n                minIndex = j;\n\n        swap( arr[i] , arr[minIndex] );\n    }\n}\n\nint main() {\n\n    // 测试排序算法辅助函数\n    int N = 20000;\n    int *arr = SortTestHelper::generateRandomArray(N,0,100000);\n    selectionSort(arr,N);\n    SortTestHelper::printArray(arr,N);\n    delete[] arr;\n\n    return 0;\n}\n```\n","tags":["算法","C++"],"categories":["Algorithm","C++"]},{"title":"类加载机制","url":"/2021/02/09/类加载机制/","content":"\n## 类加载器可以做什么\n\n### 热部署\n\n不重启Java程序的情况下，动态替换类的实现\n\n比如JSP、OSGI\n\n### 应用的模块化和隔离\n\n不同的类加载器可以加载相同的类，但互相隔离、互不影响\n\n比如：\n\n- Tomcat在一个程序中管理多个Web应用，每个Web应用有自己的classloader\n- OSGI和Java9实现动态模块化架构，每个模块有自己的ClassLoader\n\n### 可以从不同的地方灵活加载类\n\n## 为什么要学自定义classloader\n\n- 有助于我们理解相关的系统和框架，比如Tomcat\n- 在业务需要的时候，可以自定义classloader实现动态灵活的功能\n\n## 类加载的基本机制和过程\n\n首先了解下，JDK提供的几个类加载器\n\n- 启动类加载器。加载基础类，主要是rt.jar\n- 扩展类加载器。加载ext目录下的jar\n- 应用程序类加载器。加载应用程序的类，包括自己写的和引入的第三方法类库\n\n要点：类加载器之间的关系，不是继承关系，是委派关系。\n\n### 加载过程\n\n1. 判断类是否加载过了，没有就一层层向上委派给父类，最后先让启动类加载器加载\n2. 启动类加载到了，就返回Class对象，否则就让ext加载器加载\n3. ext加载器加载到了，就返回Class对象，否则就让应用类加载器加载\n4. 应用类加载器加载到了，就返回Class对象，否则返回抛异常\n\n上面的加载过程就是双亲委派，一个类加载时，委派给ext类加载器，再委派给启动类加载器\n\n这样可以避免Java基础类库被覆盖\n\nJDK允许不遵循上面的加载过程，打破双亲委派规则：\n\n- 自定义的加载顺序\n  - 即使不遵守双亲委派，以java开头的类也不能被自定义类加载器加载，这是由Java的安全机制保证的，以避免混乱。\n- 网状加载顺序\n  - OSGI和Java9模块化系统，类加载器之间的关系是一个网，每个模块有一个类加载器\n- 父加载器委派给子加载器加载\n  - JNDI服务\n\n## 理解ClassLoader\n\nClassLoader类是一个抽象类。\n\n有两个子类\n\n- AppClassLoader\n- ExtClassLoader\n\nBootstrapClassLoader并不是它的子类，BootstrapClassLoader是C++写的，用于加载java基础类的。\n\n### Class对象的API\n\n#### getClassLoader\n\ngetClassLoader获取ClassLoader，来看看ClassLoader的API\n\n- getParent\n  - 如果parent是Bootstrap ClassLoader，返回值为null\n- 静态方法getSystemClassLoader\n  - 获取默认的系统类机载器\n- loadeClass方法\n  - ![示例](https://gitee.com/jinxin.70/oss/raw/master/uPic2/VulpSW.png)\n- 深入loadClass方法\n  - ![](https://gitee.com/jinxin.70/oss/raw/master/uPic2/6HvGpS.png)\n\n#### Class.forName\n\n![](https://gitee.com/jinxin.70/oss/raw/master/uPic2/jqjhdq.png)\n\n- 第一个方法，使用系统类加载器加载\n- 第二个方法，指定ClassLoader，参数initialize表示加载后是否执行类的初始化代码（如static代码块），没有指定默认true。\n\nClass.forName和ClassLoader的loadClass方法都能加载类\n\n不同点：ClassLoader的loadClass方法不会执行类的初始化代码\n\n```java\npublic class CLInitDemo {\n    public static class Hello {\n        static {\n            System.out.println(\"hello\");\n        }\n    };\n\n    public static void main(String[] args) {\n        ClassLoader cl = ClassLoader.getSystemClassLoader();\n        String className = CLInitDemo.class.getName() + \"$Hello\";\n        try {\n            //不会初始化类，不会执行静态方法和代码块\n\t\t\tClass<?> cls = cl.loadClass(className);\n\t\t\t//会初始化类，会执行静态方法和静态代码块\n//            Class<?> cls = Class.forName(className);\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n## 类加载器的应用：可配置的策略\n\n策略模式，将不同策略实现类，配置在外部文件中，不同场合使用不同的配置，通过反射、类加载器加载配置中的类。不需要改代码就可以改变程序的行为\n\n[代码地址](https://gitee.com/jinxin.70/alpha1/commit/5fa782b61f350874eaa919c397fa21630911fb40)\n\n## 自定义ClassLoader\n\n### 一般步骤\n\n1. 继承ClassLoader\n2. 重写findClass\n    1. 从class文件位置加载类\n    2. 转成字节数组\n    3. 调用defineClass方法\n\n### 案例\n\n```java\npublic class MyClassLoader extends ClassLoader{\n    private static final String BASE_DIR = \"data/classloader/\";\n\n    @Override\n    protected Class<?> findClass(String name) throws ClassNotFoundException {\n        String fileName = name.replaceAll(\"\\\\.\", \"/\");\n        fileName = BASE_DIR + fileName + \".class\";\n        try {\n            byte[] bytes = BinaryFileUtils.readFileToByteArray(fileName);\n            return defineClass(name, bytes, 0, bytes.length);\n        } catch (IOException ex) {\n            throw new ClassNotFoundException(\"failed to load class \" + name, ex);\n        }\n    }\n}\n```\n\n### 自定义了类加载器之后呢？能干嘛？\n\n- 可以创建多个MyClassLoader，对同一个类，每个MyClassLoader都可以加载一次，得到同一个类对不同Class对象\n- 可以实现隔离\n    - 不同模块使用不同的类加载器\n- 可以实现热部署\n    - 使用自定义类加载器，加载Class，得到的就是新的，从而可以实现动态更新\n\n### 热部署实验\n\n```java\npublic class HotDeployDemo {\n    /**\n     * 实现类名称\n     */\n    private static final String CLASS_NAME = \"com.kim.base.classloader.custom.HelloImpl\";\n    /**\n     * class文件路径\n     */\n    private static final String FILE_NAME = \"target/classes/\"\n            +CLASS_NAME.replaceAll(\"\\\\.\", \"/\")+\".class\";\n    /**\n     * IHelloService实现类\n     */\n    private static volatile IHelloService helloService;\n\n    public static IHelloService getHelloService() {\n        if (helloService != null) {\n            return helloService;\n        }\n        synchronized (HotDeployDemo.class) {\n            if (helloService == null) {\n                helloService = createHelloService();\n            }\n            return helloService;\n        }\n    }\n\n    /**\n     * 通过自定义类加载器，从指定的目录加载IHelloService实现类\n     * @return\n     */\n    private static IHelloService createHelloService() {\n        try {\n            MyClassLoader cl = new MyClassLoader();\n            Class<?> cls = cl.loadClass(CLASS_NAME);\n            if (cls != null) {\n                return (IHelloService) cls.newInstance();\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n    public static void client() {\n        Thread t = new Thread() {\n            @Override\n            public void run() {\n                try {\n                    while (true) {\n                        IHelloService helloService = getHelloService();\n                        helloService.sayHello();\n                        Thread.sleep(1000);\n                    }\n                } catch (InterruptedException e) {\n                }\n            }\n        };\n        t.start();\n    }\n\n    /**\n     * 一个监视文件变化的线程，文件如果变化了，就重新加载\n     */\n    public static void monitor() {\n        Thread t = new Thread() {\n            private long lastModified = new File(FILE_NAME).lastModified();\n\n            @Override\n            public void run() {\n                try {\n                    while (true) {\n                        Thread.sleep(100);\n                        long now = new File(FILE_NAME).lastModified();\n                        if (now != lastModified) {\n                            lastModified = now;\n                            reloadHelloService();\n                        }\n                    }\n                } catch (InterruptedException e) {\n                }\n            }\n        };\n        t.start();\n    }\n\n    public static void reloadHelloService() {\n        System.out.println(\"文件被修改了，重新加载\");\n        helloService = createHelloService();\n    }\n\n    public static void main(String[] args) {\n        monitor();\n        client();\n    }\n}\n```\n\n- 我们把创建HelloService的实现的方式提取出来，通过自定义类加载器，在指定目录加载他的实现\n- 我们使用一个线程，监听自定义类加载器加载类的地方，监听具体文件的变化，有变化就重新实例化一个自定义类加载器，加载新的类，使其生效\n- 模拟客户端调用\n    - 用一个线程，无限循环去调用helloServicve的方法sayHello\n\n## 总结\n\n通过类加载器的学习，我们知道了类加载器最起码可以做如下三样事情：\n\n1. 热部署\n2. 应用的模块化和隔离\n3. 从不同的地方灵活加载\n\n我们使用的tomcat就是使用类加载器的典型例子，通过案例和实验代码的运行、调试、理解，对类加载器的应用应该会有更深的理解，对tomcat的运行机制也不会觉得那么神秘。\n\n读者自己可以试试实现一个简单的tomcat，可以实现热部署、应用的隔离。\n\n","tags":["Java","类加载器"],"categories":["Java","ClassLoader"]},{"title":"我应该写什么","url":"/2021/02/08/我应该写什么/","content":"\n折腾了一天，重新把hexo博客建好了\n\n\n\n不想再折腾了\n\n\n\n打算要写的内容，计划用博客来做什么\n\n- 记录学习过程，主要记录读书笔记、思维导图的总结、教程的总结（Java、分布式微服务、数据存储、算法、中间件源码架构设计）\n- 记录排查问题的过程\n- 记录生活中的想法（旅游、带娃、生活习惯养成、运动）\n\n\n\n不该写的内容\n\n- 不该当作备忘录\n- 不写没有体系，不写技术、生活无关的内容\n\n\n\n博客应该具备的能力\n\n- 字数统计\n- 访问统计\n- 评论系统\n- 个人简介、经历（让别人认识你）\n\n\n\n接下来，把上面博客的能力实现，然后从Java、算法开始\n\n","tags":["Diary","Life"],"categories":["Diary","Life"]}]