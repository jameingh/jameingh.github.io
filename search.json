[{"title":"归并排序基础","url":"/2021/03/22/归并排序基础/","content":"## 前要回顾\n\n前面我们学习了选择排序和插入排序，比较好理解，但是复杂度是O(n^2)\n\n不是说O(n^2)不好，在数据量不大的时候，其实是可以用的，因为实现简单。\n\n有没有更好的排序方案呢？\n\n下面看看时间复杂度是O(nlogn)的排序算法，归并排序。\n\n## 思路\n\n假如要对下面的数组排序\n\n![image-20210322195817245](https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20210322195817245.png)\n\n归并排序的思路是：把数组对半分，想办法把左边的数组排序，把右半部分排序，最后合并。\n\n在排序左半部分时，再把左半部分在对半分，并排序，合并。\n\n![image-20210322200027636](https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20210322200027636.png)\n\n这样对半分，分到最后，每一部分只有一个元素，就不能再分了，然后顺序也排好了，只需要每部分依此归并。\n\n我们看下分成了几层，\n\n![image-20210322200310337](https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20210322200310337.png)\n\n总共有log(n)层。分析：每次对半分，分多少次？log以2为底，8的对数，是4。\n\n再以O(n)的算法归并，所以总体复杂度是O(nlogn)。\n\n使用递归思想。\n\n需要开辟临时空间，辅助归并。\n\n使用三个索引对归并过程跟踪。\n\n![image-20210322203412929](https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20210322203412929.png)\n\n蓝色的箭头，表示最终在归并的过程中我们需要跟踪的位置。\n\n两个红色的箭头指向两个排好序的数组当前我们要考虑的元素。\n\n我们考虑2，1谁应该先放到最终数组中\n\n![image-20210322203551791](https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20210322203551791.png)\n\n1比2小，将1放入最终数组中，蓝色箭头移动到下一个位置\n\n![image-20210322203626303](https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20210322203626303.png)\n\n与此同时，1原先所在数据的红色指针，考虑移动到下一个位置\n\n![image-20210322203707909](https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20210322203707909.png)\n\n此时1已经在原数组中排好序了，\n\n在考虑2和4，2更小\n\n![image-20210322203816621](https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20210322203816621.png)\n\n2放入原数组第二个位置，同时原数组的蓝色指针向后移一位，\n\n![image-20210322203849566](https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20210322203849566.png)\n\n与此同时，2原来所在数组的红色指针，向后移到一个位置\n\n![image-20210322203918467](https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20210322203918467.png)\n\n再考虑3和4，\n\n![image-20210322203947587](https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20210322203947587.png)\n\n3比4小，3放入原数组的蓝色指针指向的位置，原数组蓝色指针向后移动一位\n\n![image-20210322204007067](https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20210322204007067.png)\n\n与此同时，3所在原数组的红色指针，向后移动一位。\n\n![image-20210322204118074](https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20210322204118074.png)\n\n此时比较6和4，4比6小，4放到原数组的蓝色指针指向的位置，原数组蓝色指针向后移动一位，同时4所在原数组的红色指针向后移动一位。\n\n![image-20210322204234033](https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20210322204234033.png)\n\n![image-20210322204249810](https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20210322204249810.png)\n\n指针就绪后，再考虑6和5比较，依此类推。\n\n## 难点\n\n使用了三个索引（指针），必须定义清楚。\n\n![image-20210322204429805](https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20210322204429805.png)\n\n定义i和j，为当前正在考虑的元素，k用来指向i和j比较后，最终应该放到归并数组中的位置。\n\n注意，k表示的是下一个需要放置的位置，不是归并后的最后位置。\n\n维持三个变量在实现过程中，始终符合我们的定义，是正确实现的基础。\n\n为了防止越界，需要定义另外两个变量l(left)和r(right)，分别表示最左边和最右边的位置。\n\n![image-20210322204901158](https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20210322204901158.png)\n\n还需要一个表示已经排好序的中间数组的最后一个位置m（middle）。\n\n![image-20210322205000663](https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20210322205000663.png)\n\n## C++实现\n\nmain.cpp\n\n```C++\n#include <iostream>\n#include \"SortTestHelper.h\"\n#include \"InsertionSort.h\"\n\nusing namespace std;\n\n\n// 将arr[l...mid]和arr[mid+1...r]两部分进行归并\ntemplate<typename  T>\nvoid __merge(T arr[], int l, int mid, int r){\n\n    //* VS不支持动态长度数组, 即不能使用 T aux[r-l+1]的方式申请aux的空间\n    //* 使用VS的同学, 请使用new的方式申请aux空间\n    //* 使用new申请空间, 不要忘了在__merge函数的最后, delete掉申请的空间:)\n\n    //辅助空间对大小，由于是前闭后闭区间，所以是r-l+1\n    T aux[r-l+1];\n    //T *aux = new T[r-l+1];\n\n    //临时空间初始化\n    for( int i = l ; i <= r; i ++ )\n        //aux是从零开始的，但是处理的arr空间是动态的l开始的，两个数组有一个l的距离偏移\n        aux[i-l] = arr[i];\n\n    // 初始化，i指向左半部分的起始索引位置l；j指向右半部分起始索引位置mid+1\n    int i = l, j = mid+1;\n    //从l遍历到r，左边遍历到右边，决定k的位置\n    for( int k = l ; k <= r; k ++ ){\n\n        if( i > mid ){  // 如果左半部分元素已经全部处理完毕\n            arr[k] = aux[j-l]; j ++;\n        }\n        else if( j > r ){  // 如果右半部分元素已经全部处理完毕\n            arr[k] = aux[i-l]; i ++;\n        }\n        else if( aux[i-l] < aux[j-l] ) {  // 左半部分所指元素 < 右半部分所指元素\n            arr[k] = aux[i-l]; i ++;\n        }\n        else{  // 左半部分所指元素 >= 右半部分所指元素\n            arr[k] = aux[j-l]; j ++;\n        }\n    }\n\n    //delete[] aux;\n}\n\n// 递归使用归并排序,对arr[l...r]的范围进行排序\ntemplate<typename T>\nvoid __mergeSort(T arr[], int l, int r){\n\n    //处理递归到底的情况，l>=r表示要处理的是至多一个元素的情况\n    if( l >= r )\n        return;\n\n    //计算中点位置 思考：当l和r很大时，l+r可能会溢出，如何避免\n    int mid = (l+r)/2;\n    //对一半进行归并排序\n    __mergeSort(arr, l, mid);\n    //对另一半进行归并排序\n    __mergeSort(arr, mid+1, r);\n    //合并上面对两半数据\n    __merge(arr, l, mid, r);\n}\n\ntemplate<typename T>\nvoid mergeSort(T arr[], int n){\n\n    __mergeSort( arr , 0 , n-1 );\n}\n\n\n// 比较InsertionSort和MergeSort两种排序算法的性能效率\n// 整体而言, MergeSort的性能最优, 对于近乎有序的数组的特殊情况, 见测试2的详细注释\nint main() {\n\n    // Merge Sort是我们学习的第一个O(nlogn)复杂度的算法\n    // 可以在1秒之内轻松处理100万数量级的数据\n    // 注意：不要轻易尝试使用SelectionSort, InsertionSort或者BubbleSort处理100万级的数据\n    // 否则，你就见识了O(n^2)的算法和O(nlogn)算法的本质差异：）\n    int n = 50000;\n\n    // 测试1 一般性测试\n    cout<<\"Test for random array, size = \"<<n<<\", random range [0, \"<<n<<\"]\"<<endl;\n    int* arr1 = SortTestHelper::generateRandomArray(n,0,n);\n    int* arr2 = SortTestHelper::copyIntArray(arr1, n);\n\n    SortTestHelper::testSort(\"Insertion Sort\", insertionSort, arr1, n);\n    SortTestHelper::testSort(\"Merge Sort\",     mergeSort,     arr2, n);\n\n    delete[] arr1;\n    delete[] arr2;\n\n    cout<<endl;\n\n\n    // 测试2 测试近乎有序的数组\n    // 对于近乎有序的数组, 数组越有序, InsertionSort的时间性能越趋近于O(n)\n    // 所以可以尝试, 当swapTimes比较大时, MergeSort更快\n    // 但是当swapTimes小到一定程度, InsertionSort变得比MergeSort快\n    int swapTimes = 10;\n    assert( swapTimes >= 0 );\n\n    cout<<\"Test for nearly ordered array, size = \"<<n<<\", swap time = \"<<swapTimes<<endl;\n    arr1 = SortTestHelper::generateNearlyOrderedArray(n,swapTimes);\n    arr2 = SortTestHelper::copyIntArray(arr1, n);\n\n    SortTestHelper::testSort(\"Insertion Sort\", insertionSort, arr1, n);\n    SortTestHelper::testSort(\"Merge Sort\",     mergeSort,     arr2, n);\n\n    delete[] arr1;\n    delete[] arr2;\n\n    return 0;\n}\n```\n\n[完整代码地址](https://gitee.com/jinxin.70/alpha1/commit/a282842861ad89dea328e02449972c09ab5fd7fd)\n\n\n\n\n","tags":["算法","C++"],"categories":["Algorithm","C++"]},{"title":"插入排序","url":"/2021/03/16/插入排序/","content":"## 前要回顾\n\n前面我们提供了一个对数据排序的方案，是选择排序。\n\n排序的过程，回顾一下。\n\n如果要对数组进行从小到大排序，选择排序怎么做呢？\n\n我们对数组的每个位置进行遍历，举个例子：\n\n比如一开始，第一个位置，我们要放置最小的元素到这个位置，于是从所有元素中选择一个最小的。然后和第一个位置的元素交换，这样，就确定了最小的数。\n\n下面确定第二小的数，就是从第一个位置后面所有的元素中找到最小的，然后交换位置。\n\n依此类推，完成从小到大的排序。\n\n这就是选择排序的一般过程。\n\n总体来看，需要两层循环去完成上述过程，第一层循环，用于确定每个位置上的应该存放的合适的数。\n\n第二层是在剩余未排序的元素中找到这个合适的数的位置。\n\n时间复杂度是O(n^2)\n\n除了选择排序，有没有其他的方案呢？\n\n有，再来看看插入排序，是另一种思路。\n\n## 插入排序\n\n假如要对下面的数组排序\n\n![image-20210310184137684](https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20210310184137684.png)\n\n第一个元素8，不动，对于8，他是排好序的，继续下一个元素\n\n![image-20210310184203449](https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20210310184203449.png)\n\n我们想要把第二个元素6，插入到前面元素的合适位置，\n\n![image-20210310184421990](https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20210310184421990.png)\n\n6比8小，交换位置\n\n![image-20210310184642749](https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20210310184642749.png)\n\n下面开始，将2插入到前面合适的位置，\n\n![image-20210310184711464](https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20210310184711464.png)\n\n2和8比较，比8小，和8交换位置\n\n![image-20210310184747973](https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20210310184747973.png)\n\n2再和6比，2比6小，交换位置\n\n![image-20210310184816861](https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20210310184816861.png)\n\n下面开始，对3\n\n3依次比较前面的数，然后交换位置，直到找到合适的位置\n\n![image-20210311000858595](https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20210311000858595.png)\n\n![image-20210311000911306](https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20210311000911306.png)\n\n插入排序的原理，可以提前终止循环，原则上比选择排序快，但是请看下面的写法。\n\n## 插入排序代码\n\n```java\nfor (int i = 1; i < n; ++i) {\n\n        //找到合适的位置插入\n//        for (int j = i; j > 0; j--) {\n//            if(arr[j] < arr[j-1]){\n//                swap(arr[j], arr[j-1]);\n//            }else{\n//                break;\n//            }\n//        }\n\n        // 写法2\n        for( int j = i ; j > 0 && arr[j] < arr[j-1] ; j -- )\n            swap( arr[j] , arr[j-1] );\n    }\n```\n\n## 插入排序改进\n\n上面的swap交换操作比比较操作慢。我们是放在内层for循环里执行的，效率差。对比选择排序，我们通过比较找到要插入的位置，在外层循环插入，所以上面的插入排序的写法效率反而比选择排序慢。\n\n![image-20210316190740449](https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20210316190740449.png)\n\n先复制一份6，判断6是不是适合当前位置\n\n![image-20210316190934269](https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20210316190934269.png)\n\n发现6比8小，8应该在当前位置，把8向后移动一位\n\n![image-20210316191027875](https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20210316191027875.png)\n\n然后比较6现在是不是应该在第一个位置，前面没有可比的元素了，所以把6赋值到第一个位置\n\n![image-20210316191117718](https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20210316191117718.png)\n\n6、8此时排好序\n\n![image-20210316191137953](https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20210316191137953.png)\n\n再考察2\n\n![image-20210316191156617](https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20210316191156617.png)\n\n先复制一份2的副本\n\n![image-20210316191214977](https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20210316191214977.png)\n\n2比前一个数8小，所以应该把8向后移动一位\n\n![image-20210316191303808](https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20210316191303808.png)\n\n再向前比较，2和6比较，比6小，应该将6向后移动一位。\n\n![image-20210316191344992](https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20210316191344992.png)\n\n此时2所在的位置，已经是第一个位置了，前面没有可比的元素，那么将2复制到第一个位置\n\n![image-20210316191429779](https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20210316191429779.png)\n\n此时，2、6、8已经排好序，再看下一个位置的数3\n\n依然复制这个位置上的数3。\n\n![image-20210316191502735](https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20210316191502735.png)\n\n依次和前面的数比较，如果比前面的数小，前面的数向后移动一位。\n\n![image-20210316191603847](https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20210316191603847.png)\n\n\n\n![image-20210316191617319](https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20210316191617319.png)\n\n![image-20210316191627434](https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20210316191627434.png)\n\n![image-20210316191636169](https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20210316191636169.png)\n\n**和一开始的不同时，我们把一次次的交换操作改成了比较**\n\n```java\ntemplate<typename T>\nvoid insertionSort(T arr[], int n){\n\n    for( int i = 1 ; i < n ; i ++ ) {\n\n        // 寻找元素arr[i]合适的插入位置\n        // 写法1\n//        for( int j = i ; j > 0 ; j-- )\n//            if( arr[j] < arr[j-1] )\n//                swap( arr[j] , arr[j-1] );\n//            else\n//                break;\n\n        // 写法2\n//        for( int j = i ; j > 0 && arr[j] < arr[j-1] ; j -- )\n//            swap( arr[j] , arr[j-1] );\n\n        // 写法3\n        //使用e保存每一次要处理的外层元素\n        T e = arr[i];\n        int j; // j保存元素e应该插入的位置\n        for (j = i; j > 0 && arr[j-1] > e; j--)\n            //把前一个位置的元素向后移动一位\n            arr[j] = arr[j-1];\n        //将e放到合适的位置\n        arr[j] = e;\n    }\n\n    return;\n}\n```\n\n插入排序，**在数组基本有序的情况下，效率非常高！**\n\n## 选择排序和插入排序比较\n\n- 都是O(n^2)复杂度\n- 插入排序在数组近乎有序的时候，效率非常高\n\n为什么插入排序在数据近乎有序时，效率比选择排序高。\n\n因为选择排序，是从剩余位置找到最小的数，找最小数这个过程，要比较剩余的所有元素才能找到最小值\n\n插入排序，是把当前位置的元素和前面排好序的元素比较，找到一个合适的位置，由于前面是排好序的，\n\n所以在元素基本有序的情况下，插入比较不需要和前面所有元素比较，就能确定合适的位置。\n\n","tags":["算法","C++"],"categories":["Algorithm","C++"]},{"title":"MySQL联合索引和最左前缀原则理解一","url":"/2021/03/11/最左前缀/","content":"\n如果给 user 表中的 username pwd 字段创建了复合索引那么使用以下SQL 都是可以命中索引:\n\n```sql\nselect username from user where username='zhangsan' and pwd ='axsedf1sd'\n\nselect username from user where pwd ='axsedf1sd' and username='zhangsan'\n\nselect username from user where username='zhangsan'\n```\n\n但是使用\n\n```sql\nselect username from user where pwd ='axsedf1sd'\n```\n\n是不能命中索引的。\n\n上面是从[最左前缀索引](https://crossoverjie.top/JCSprout/#/db/SQL-optimization?id=%e6%9c%80%e5%b7%a6%e5%89%8d%e7%bc%80%e9%97%ae%e9%a2%98)这篇文章看到的\n\n\n\n## 为什么``select username from user where pwd ='axsedf1sd' and username='zhangsan'``会走索引？\n\n因为mysql优化器对联合索引，等值条件、and条件有优化，会调整顺序。\n\n扩展：可以进一步看看优化器相关知识，更好的了解优化器的行为\n\n## Using where; Using index是什么意思？\n\n使用explain分析下面这个语句\n\n```sql\nEXPLAIN select username from user where pwd ='axsedf1sd'\n```\n\n得到的结果如下：\n\n![image-20210311163448369](https://gitee.com/jinxin.70/oss/raw/master/uPic/image-20210311163448369_2021_03_11_16_34_48.png)\n\n看到type是index，Extra是``Using where; Using index``\n\n### type是index表示什么意思？\n\n> type列表示存储引擎查询数据时采用的方式。比较重要的一个属性，通过它可以判断出查询是全表扫描还 是基于索引的部分扫描。常用属性值如下，从上至下效率依次增强。\n>\n> - ALL：表示全表扫描，性能最差。\n> - index：表示基于索引的全表扫描，先扫描索引再扫描全表数据。\n> - range：表示使用索引范围查询。使用>、>=、<、<=、in等等。\n> - ref：表示使用非唯一索引进行单值查询。\n> - eq_ref：一般情况下出现在多表join查询，表示前面表的每一个记录，都只能匹配后面表的一 行结果。\n> - const：表示使用主键或唯一索引做等值查询，常量查询。\n> - NULL：表示不用访问表，速度最快。\n\n可以看到，type是index，效率不好\n\n### Using where; Using index是什么意思\n\n表示在索引树上包括要查找的列，但是不能按照顺序查找到，必须通过条件筛选\n\n### 什么是\"走索引\"？\n\n如果Extra只有Using index，表示索引树上有要查找的列，并且可以按照顺序查找到。也就是常说的\"走索引\"的意思\n\n\n\n## 总结\n\n- 常说的\"走索引\"，用explain分析后，Extra列的值是``Using index``，而``Using where;Using index``不走索引\n- ``Using where;Using index``表示不走索引，索引树上能够扫描到要查找的列，但是**不能按照顺序查找到，只能按照筛选条件查找**\n\n- \"走索引\"的意思是，要查找的列在索引树上可以扫描到，并且是可以**按照索引顺序**查找到。","tags":["MySQL","数据库调优"],"categories":["MySQL","数据库"]},{"title":"动态代理","url":"/2021/02/14/动态代理/","content":"## 可以干什么\n\n- 可以在运行时动态创建一个类，实现一个或多个接口，可以在不修改原有类的基础上动态为通过该类获取的对象添加方法、修改行为（增强）\n- 动态代理是实现面向切面编程AOP的基础\n- AOP可以干什么？\n    - 日志、性能监控、权限检查、数据库事务\n    - AOP切面通过将切面逻辑和主体逻辑分离，使代码更优雅，对代码侵入低\n\n## 什么是代理\n\n和生活中的代理的意思类似。一般至少有一个实际对象，\n代理的外部功能和实际对象一般是一样的，用户与代理打交道，不直接接触实际对象。\n\n## 代理存在的价值\n\n- 节省成本，实际对象创建的成本开销大，按需延迟加载，\n  创建代理时并不真正创建实际对象，而只是保存实际对象的地址，在需要时再加载或创建\n- 执行权限检查，代理检查权限后，再调用实际对象\n- 屏蔽网络差异和复杂性，代理在本地，而实际对象在其他服务器上，调用本地代理时，本地代理请求其他服务器\n\n## 静态代理\n\n- 业务接口、实际类、代理类\n\n- 实际类实现业务接口，实现接口中的方法\n- 代理类也实现业务接口，并维持一个业务接口实现类的引用，通过构造函数注入实际类的引用，\n  实现的方法中实际调用的是实际类的方法\n    - 可以在调用实际方法的前后，做增强逻辑，比如在调用前后输出日志\n- 静态代理的代理类，是在写代码时就固定的，所以称为静态代理\n- 输出跟踪调试信息是一个通用需求，静态代理只能为某个类增强，要为某些类增强，只能每个类都写一个代理类，不现实。这就需要动态代理了。\n\n## 和适配器、装饰器的区别\n\n- 适配器\n    - 适配器提供了一个不一样的新接口\n- 装饰器\n    - 装饰器是对原接口起到了装饰的作用，可能增加了新接口、修改了原有的行为等，代理一般不改变接口\n\n我们不过于强调他们的差别，没有争论的意义，可以看作是代理的一种变体\n\n## 什么是动态代理\n\n代理类是运行时动态生成的。\n\n怎么动态生成？\n\n## 动态代理的两种方式\n\n### JDK提供的\n\n#### 实现InvocationHandler的接口，实现其invoke方法，这就是实现增强逻辑\n\ninvoke方法，三个参数\n\n- proxy，代理对象本身，一般不用\n- method，正在被调用的方法\n- args，表示方法的参数\n\n#### 怎么创建类\n\n通过Proxy.newProxyInstance，三个参数\n\n- classloader类加载器\n- 代理类要实现的接口列表\n- 实现增强逻辑的类，即实现InvocationHandler接口的类，对代理接口所有方法的调用都会转给该方法\n\n返回某个接口列表中的类型，只能强转为接口，不能是实现类\n\n\n\n#### 示例\n\n```java\npublic class SimpleJDKDynamicProxyDemo {\n    interface IService {\n        void sayHello();\n    }\n\n    static class RealService implements IService {\n\n        @Override\n        public void sayHello() {\n            System.out.println(\"hello\");\n        }\n    }\n\n    static class SimpleInvocationHandler implements InvocationHandler {\n        private Object realObj;\n\n        public SimpleInvocationHandler(Object realObj) {\n            this.realObj = realObj;\n        }\n\n        @Override\n        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n            System.out.println(\"entering \" + method.getName());\n            Object result = method.invoke(realObj, args);\n            System.out.println(\"leaving \" + method.getName());\n            return result;\n        }\n    }\n\n    public static void main(String[] args) {\n        IService realService = new RealService();\n        IService proxyService = (IService) Proxy.newProxyInstance(IService.class.getClassLoader(),\n                new Class<?>[] { IService.class }, new SimpleInvocationHandler(realService));\n        proxyService.sayHello();\n    }\n}\n```\n\n#### 基本原理\n\n上面例子生成的类如下：\n\n![](https://gitee.com/jinxin.70/oss/raw/master/uPic/DbDyLN_2021_02_07_15_28_27.png)\n\n生成的类是Proxy的子类，结合Proxy类看\n\n![](https://gitee.com/jinxin.70/oss/raw/master/uPic/HRFvbZ_2021_02_07_15_32_52.png)\n\n从上面可以看出，$Proxy0的构造方法传入InvocationHandler，最终赋值给父类Proxy的属性h，后续的其他方法调用都转发到这个InvocationHandler的子类中，比如，sayHello方法，调用的是this.h.invoke(this, m3, null);对于Object中的方法，如hashcode、equals和toString，$Proxy0同样转发给了InvocationHandler\n\n我们怎么知道$Proxy0的定义的呢？对于oracle的JVM，可以配置java的一个属性得到，比如\njava -Dsun.misc.ProxyGenerator.saveGeneratedFiles=true shuo.laoma.dynamic.c86.SimpleJDKDynamicProxyDemo\n\n以上命令会把动态生成的代理类$Proxy0保存到文件$Proxy0.class中，通过一些反编译器工具比如JD-GUI（http://jd.benow.ca）就可以得到源码。\n\n理解了代理类的定义，后面的代码就比较容易理解了，就是获取构造方法，创建代理对象\n\n#### 动态代理的优点\n\n不局限于某个类，可以为有相同需求的类实现切面逻辑\n\n#### JDK动态代理局限性\n\n只能为接口创建代理，返回的代理对象，也只能转换到某个接口类型\n\n\n### cglib\n\n可以为没有接口的类创建代理。\n\n#### 基本用法示例\n\n![](https://gitee.com/jinxin.70/oss/raw/master/uPic/RpCl6V_2021_02_07_16_10_18.png)\n\n- Enhancer类的setSuperclass设置被代理的类\n- setCallback设置被代理类的public非final方法被调用时的处理类\n- Enhancer类支持多种类型，这里使用的类实现了MethodInterceptor接口\n- 这里调用被代理类的方法只能是proxy.invokeSuper(object, args)，不能是method.invoke(object, args)\n\ncglib的实现机制，是通过**继承**实现的，动态创建一个类，但这个类的父类是被代理类，代理类重写了父类的所有public非final方法，改为调用Callback中的相关方法，在上例中，调用SimpleInterceptor的intercept方法。\n\n### JDK动态代理和cglib动态代理的比较\n\n- JDK动态代理面向一组接口，它为这些接口动态创建了一个实现类。\n    - 接口的具体实现逻辑是通过自定义的InvocationHandler实现的\n    - 这个实现是自定义的，也就是说，其背后都不一定有真正被代理的对象，也可能有多个实际对象，根据情况动态选择\n    - **代理的是对象，需要先有一个实际的对象**，自定义的InvocationHandler引用该对象，\n      然后创建一个代理类和代理对象，客户端访问的是代理对象，代理对象最后再调用实际对象的方法\n- cglib代理面向一个具体的类\n    - 动态创建一个新类，继承该类，重写其方法\n    - cglib代理的是类，创建的对象只有一个\n\n## 动态代理的应用——AOP\n\n实现原理\n\n[代码地址](https://gitee.com/jinxin.70/alpha1/tree/ce6dbb64df7848548723e9caa981ba6f371b2f0e/java-base/src/main/java/com/kim/base/proxy/aop)\n\n## 总结\n\n本文主要学习了动态代理，读完后应该知道这些内容\n\n- 什么是代理\n- 什么是静态代理？和适配器、装饰器模式的区别是什么\n- 为什么实际使用很少用静态代理\n- Java语言中动态代理的两种方式是什么？内部是如何去实现的？\n- 动态代理可以用来做什么？\n\n基本上是层层递进，到最后，动态代理的典型应用AOP，可以说是很多框架的基础，必须掌握其原理。","tags":["Java","动态代理"],"categories":["Java","动态代理"]},{"title":"选择排序","url":"/2021/02/12/selection-sort/","content":"\n## 排序过程\n\n假如对如下数组排序\n\n![image-20210212212637607](https://gitee.com/jinxin.70/oss/raw/master/uPic/image-20210212212637607_2021_02_12_21_26_37.png)\n\n我们打算从小到大排序\n\n### 第一轮\n\n先找到数组中最小的，是1\n\n![image-20210212212805249](https://gitee.com/jinxin.70/oss/raw/master/uPic/image-20210212212805249_2021_02_12_21_28_05.png)\n\n然后将1和数组中第一个位置上的数交换，这样，1就是最终的位置了\n\n![image-20210212212837283](https://gitee.com/jinxin.70/oss/raw/master/uPic/image-20210212212837283_2021_02_12_21_28_37.png)\n\n### 第二轮\n\n那么1排好了，我们从剩下的数里面找最小的数，是2\n\n![image-20210212212905854](https://gitee.com/jinxin.70/oss/raw/master/uPic/image-20210212212905854_2021_02_12_21_29_06.png)\n\n我们将2和第二个位置上的数交换位置\n\n![image-20210212213045447](https://gitee.com/jinxin.70/oss/raw/master/uPic/image-20210212213045447_2021_02_12_21_30_45.png)\n\n此时，1和2都已经固定好了位置\n\n![image-20210212213108930](https://gitee.com/jinxin.70/oss/raw/master/uPic/image-20210212213108930_2021_02_12_21_31_09.png)\n\n### 第三轮\n\n再从第三个位置往后找最小的数，然后与第三个位置上的数交换位置\n\n![image-20210212213214529](https://gitee.com/jinxin.70/oss/raw/master/uPic/image-20210212213214529_2021_02_12_21_32_14.png)\n\n![image-20210212213226904](https://gitee.com/jinxin.70/oss/raw/master/uPic/image-20210212213226904_2021_02_12_21_32_27.png)\n\n依此类推，找到数组末尾就排好序了\n\n### 第四轮\n\n![image-20210212213300337](https://gitee.com/jinxin.70/oss/raw/master/uPic/image-20210212213300337_2021_02_12_21_33_00.png)\n\n![image-20210212213317201](https://gitee.com/jinxin.70/oss/raw/master/uPic/image-20210212213317201_2021_02_12_21_33_17.png)\n\n### 第五轮\n\n![image-20210212213342282](https://gitee.com/jinxin.70/oss/raw/master/uPic/image-20210212213342282_2021_02_12_21_33_42.png)\n\n![image-20210212213355567](https://gitee.com/jinxin.70/oss/raw/master/uPic/image-20210212213355567_2021_02_12_21_33_55.png)\n\n### 第六轮\n\n![image-20210212213442090](https://gitee.com/jinxin.70/oss/raw/master/uPic/image-20210212213442090_2021_02_12_21_34_42.png)\n\n![image-20210212213453305](https://gitee.com/jinxin.70/oss/raw/master/uPic/image-20210212213453305_2021_02_12_21_34_53.png)\n\n### 第七轮\n\n![image-20210212213512606](https://gitee.com/jinxin.70/oss/raw/master/uPic/image-20210212213512606_2021_02_12_21_35_12.png)\n\n### 第八轮\n\n![image-20210212213535214](https://gitee.com/jinxin.70/oss/raw/master/uPic/image-20210212213535214_2021_02_12_21_35_35.png)\n\n## C++实现\n\n```c++\n#include <iostream>\n\nusing namespace std;\n/**\n * 选择排序\n * @param arr\n * @param n\n */\nvoid selectionSort(int arr[], int n){\n    for (int i = 0; i < n; ++i) {\n        //寻找[1,n)区间里的最小值\n        int minIndex = i;\n        for (int j = i + 1; j < n; ++j) {\n            if(arr[j] < arr[minIndex]){\n                minIndex = j;\n            }\n        }\n        swap(arr[i], arr[minIndex]);\n    }\n}\n\nint main(){\n    int a[10] = {10,9,8,7,6,5,4,3,2,1};\n    selectionSort(a, 10);\n\n    for (int i = 0; i < 10; ++i) {\n        cout<<a[i]<<\" \";\n    }\n    cout<<endl;\n    return 0;\n}\n```\n\n\n\n## 使用模板（范型）编写算法\n\n上面的实现，只能对int数组排序，我们需要对不同的类型排序，所以需要用到模板，有的语言叫范型。\n\n**Student.h**\n\n```c++\n\n#ifndef ALGORITHMCPLUSPLUS_STUDENT_H\n#define ALGORITHMCPLUSPLUS_STUDENT_H\n\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\nstruct Student{\n    string name;\n    int score;\n\n    // 重载小于运算法,定义Student之间的比较方式\n    // 如果分数相等，则按照名字的字母序排序\n    // 如果分数不等，则分数高的靠前\n    bool operator<(const Student& otherStudent){\n        return score != otherStudent.score ?\n               score > otherStudent.score : name < otherStudent.name;\n    }\n\n    // 重载<<符号, 定义Student实例的打印输出方式\n    // * 很多同学看到这里的C++语法, 头就大了, 甚至还有同学表示要重新学习C++语言\n    // * 对于这个课程, 大可不必。C++语言并不是这个课程的重点,\n    // * 大家也完全可以使用自己的方式书写代码, 最终只要能够打印出结果就好了, 比如设置一个成员函数, 叫做show()...\n    // * 推荐大家阅读我在问答区向大家分享的一个学习心得: 【学习心得分享】请大家抓大放小，不要纠结于C++语言的语法细节\n    // * 链接: http://coding.imooc.com/learn/questiondetail/4100.html\n    friend ostream& operator<<(ostream &os, const Student &student){\n\n        os<<\"Student: \"<<student.name<<\" \"<<student.score<<endl;\n        return os;\n    }\n};\n\n#endif //ALGORITHMCPLUSPLUS_STUDENT_H\n```\n\n**main.cpp**\n\n```c++\n#include <iostream>\n\nusing namespace std;\n#include \"Student.h\"\ntemplate<typename T>\n/**\n * 选择排序\n * @param arr\n * @param n\n */\nvoid selectionSort(T arr[], int n){\n    for (int i = 0; i < n; ++i) {\n        //寻找[1,n)区间里的最小值\n        int minIndex = i;\n        for (int j = i + 1; j < n; ++j) {\n            if(arr[j] < arr[minIndex]){\n                minIndex = j;\n            }\n        }\n        swap(arr[i], arr[minIndex]);\n    }\n}\n\nint main(){\n    int a[10] = {10,9,8,7,6,5,4,3,2,1};\n    selectionSort(a, 10);\n\n    for (int i = 0; i < 10; ++i) {\n        cout<<a[i]<<\" \";\n    }\n    cout<<endl;\n\n    float b[4] = {4.4,3.3,2.2,1.1};\n    selectionSort(b, 4);\n    for (int i = 0; i < 4; ++i) {\n        cout<<b[i]<< \" \";\n    }\n    cout<<endl;\n\n    string c[4] = {\"D\",\"C\",\"B\",\"A\"};\n    selectionSort(c,4);\n    for( int i = 0 ; i < 4 ; i ++ )\n        cout<<c[i]<<\" \";\n    cout<<endl;\n\n    Student d[4] = { {\"D\",90} , {\"C\",100} , {\"B\",95} , {\"A\",95} };\n    selectionSort(d,4);\n    for( int i = 0 ; i < 4 ; i ++ )\n        cout<<d[i];\n    cout<<endl;\n    return 0;\n}\n```\n\n## 随机生成算法测试用例（选学）\n\n思考🤔：\n\n我们上面代码的测试用例是硬编码的，我们希望生成自动生成。\n\n**SortTestHelper.h**\n\n```c++\n#ifndef ALGORITHMCPLUSPLUS_SORTTESTHELPER_H\n#define ALGORITHMCPLUSPLUS_SORTTESTHELPER_H\n#include <iostream>\n#include <ctime>\n#include <cassert>\n\nusing namespace std;\n\nnamespace SortTestHelper {\n// 生成有n个元素的随机数组,每个元素的随机范围为[rangeL, rangeR]\n    int *generateRandomArray(int n, int rangeL, int rangeR) {\n\n        assert(rangeL <= rangeR);\n\n        int *arr = new int[n];\n\n        srand(time(NULL));\n        for (int i = 0; i < n; i++)\n            arr[i] = rand() % (rangeR - rangeL + 1) + rangeL;\n        return arr;\n    }\n\n    // 打印arr数组的所有内容\n    template<typename T>\n    void printArray(T arr[], int n) {\n\n        for (int i = 0; i < n; i++)\n            cout << arr[i] << \" \";\n        cout << endl;\n\n        return;\n    }\n  // 判断arr数组是否有序\n    template<typename T>\n    bool isSorted(T arr[], int n) {\n\n        for (int i = 0; i < n - 1; i++)\n            if (arr[i] > arr[i + 1])\n                return false;\n\n        return true;\n    }\n\n    // 测试sort排序算法排序arr数组所得到结果的正确性和算法运行时间\n    // * 使用VS编码的同学, 对于函数指针的写法和调用方法可能和课程中介绍的有所不同;\n    // * 并且不同版本的VS, 其具体语法可能也有差异, 这是因为VS的编译器不完全是按照C++的标准实现的;\n    // * 本课程按照C++11的标准进行书写。对于VS编译器带来的语法差异, 希望同学们可以自己在网上查找相关资料解决;\n    // * 大家也可以在课程的官方QQ群中交流\n    // * 另外, 使用函数指针本身并不是这个课程的重点, 大家也完全可以使用自己的方式书写代码, 最终只要能够测试出自己书写的算法的效率即可\n    // * 推荐大家阅读我在问答区向大家分享的一个学习心得: 【学习心得分享】请大家抓大放小，不要纠结于C++语言的语法细节\n    // * 链接: http://coding.imooc.com/learn/questiondetail/4100.html\n    template<typename T>\n    void testSort(const string &sortName, void (*sort)(T[], int), T arr[], int n) {\n\n        clock_t startTime = clock();\n        sort(arr, n);\n        clock_t endTime = clock();\n\n        assert(isSorted(arr, n));\n        cout << sortName << \" : \" << double(endTime - startTime) / CLOCKS_PER_SEC << \" s\" << endl;\n//CLOCKS_PER_SEC表示每秒运行的时间周期数\n        return;\n    }\n};\n#endif //ALGORITHMCPLUSPLUS_SORTTESTHELPER_H\n```\n\ntestSort函数的入参void (*sort)(T[], int)是对一个函数的声明，其中\n\n- void 是返回值，表示返回void\n\n- *sort是函数指针\n\n- (T[], int)表示参数，T数组和int类型变量表示长度\n\n并且在函数声明上方要对T进行声明，template<typename T>\n\n**main.cpp**\n\n```c++\n#include <iostream>\n#include \"SortTestHelper.h\"\n\nusing namespace std;\n\ntemplate<typename T>\nvoid selectionSort(T arr[], int n){\n\n    for(int i = 0 ; i < n ; i ++){\n\n        int minIndex = i;\n        for( int j = i + 1 ; j < n ; j ++ )\n            if( arr[j] < arr[minIndex] )\n                minIndex = j;\n\n        swap( arr[i] , arr[minIndex] );\n    }\n}\n\nint main() {\n\n    // 测试排序算法辅助函数\n    int N = 20000;\n    int *arr = SortTestHelper::generateRandomArray(N,0,100000);\n    selectionSort(arr,N);\n    SortTestHelper::printArray(arr,N);\n    delete[] arr;\n\n    return 0;\n}\n```\n","tags":["算法","C++"],"categories":["Algorithm","C++"]},{"title":"类加载机制","url":"/2021/02/09/类加载机制/","content":"\n## 类加载器可以做什么\n\n### 热部署\n\n不重启Java程序的情况下，动态替换类的实现\n\n比如JSP、OSGI\n\n### 应用的模块化和隔离\n\n不同的类加载器可以加载相同的类，但互相隔离、互不影响\n\n比如：\n\n- Tomcat在一个程序中管理多个Web应用，每个Web应用有自己的classloader\n- OSGI和Java9实现动态模块化架构，每个模块有自己的ClassLoader\n\n### 可以从不同的地方灵活加载类\n\n## 为什么要学自定义classloader\n\n- 有助于我们理解相关的系统和框架，比如Tomcat\n- 在业务需要的时候，可以自定义classloader实现动态灵活的功能\n\n## 类加载的基本机制和过程\n\n首先了解下，JDK提供的几个类加载器\n\n- 启动类加载器。加载基础类，主要是rt.jar\n- 扩展类加载器。加载ext目录下的jar\n- 应用程序类加载器。加载应用程序的类，包括自己写的和引入的第三方法类库\n\n要点：类加载器之间的关系，不是继承关系，是委派关系。\n\n### 加载过程\n\n1. 判断类是否加载过了，没有就一层层向上委派给父类，最后先让启动类加载器加载\n2. 启动类加载到了，就返回Class对象，否则就让ext加载器加载\n3. ext加载器加载到了，就返回Class对象，否则就让应用类加载器加载\n4. 应用类加载器加载到了，就返回Class对象，否则返回抛异常\n\n上面的加载过程就是双亲委派，一个类加载时，委派给ext类加载器，再委派给启动类加载器\n\n这样可以避免Java基础类库被覆盖\n\nJDK允许不遵循上面的加载过程，打破双亲委派规则：\n\n- 自定义的加载顺序\n  - 即使不遵守双亲委派，以java开头的类也不能被自定义类加载器加载，这是由Java的安全机制保证的，以避免混乱。\n- 网状加载顺序\n  - OSGI和Java9模块化系统，类加载器之间的关系是一个网，每个模块有一个类加载器\n- 父加载器委派给子加载器加载\n  - JNDI服务\n\n## 理解ClassLoader\n\nClassLoader类是一个抽象类。\n\n有两个子类\n\n- AppClassLoader\n- ExtClassLoader\n\nBootstrapClassLoader并不是它的子类，BootstrapClassLoader是C++写的，用于加载java基础类的。\n\n### Class对象的API\n\n#### getClassLoader\n\ngetClassLoader获取ClassLoader，来看看ClassLoader的API\n\n- getParent\n  - 如果parent是Bootstrap ClassLoader，返回值为null\n- 静态方法getSystemClassLoader\n  - 获取默认的系统类机载器\n- loadeClass方法\n  - ![示例](https://gitee.com/jinxin.70/oss/raw/master/uPic2/VulpSW.png)\n- 深入loadClass方法\n  - ![](https://gitee.com/jinxin.70/oss/raw/master/uPic2/6HvGpS.png)\n\n#### Class.forName\n\n![](https://gitee.com/jinxin.70/oss/raw/master/uPic2/jqjhdq.png)\n\n- 第一个方法，使用系统类加载器加载\n- 第二个方法，指定ClassLoader，参数initialize表示加载后是否执行类的初始化代码（如static代码块），没有指定默认true。\n\nClass.forName和ClassLoader的loadClass方法都能加载类\n\n不同点：ClassLoader的loadClass方法不会执行类的初始化代码\n\n```java\npublic class CLInitDemo {\n    public static class Hello {\n        static {\n            System.out.println(\"hello\");\n        }\n    };\n\n    public static void main(String[] args) {\n        ClassLoader cl = ClassLoader.getSystemClassLoader();\n        String className = CLInitDemo.class.getName() + \"$Hello\";\n        try {\n            //不会初始化类，不会执行静态方法和代码块\n\t\t\tClass<?> cls = cl.loadClass(className);\n\t\t\t//会初始化类，会执行静态方法和静态代码块\n//            Class<?> cls = Class.forName(className);\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n## 类加载器的应用：可配置的策略\n\n策略模式，将不同策略实现类，配置在外部文件中，不同场合使用不同的配置，通过反射、类加载器加载配置中的类。不需要改代码就可以改变程序的行为\n\n[代码地址](https://gitee.com/jinxin.70/alpha1/commit/5fa782b61f350874eaa919c397fa21630911fb40)\n\n## 自定义ClassLoader\n\n### 一般步骤\n\n1. 继承ClassLoader\n2. 重写findClass\n    1. 从class文件位置加载类\n    2. 转成字节数组\n    3. 调用defineClass方法\n\n### 案例\n\n```java\npublic class MyClassLoader extends ClassLoader{\n    private static final String BASE_DIR = \"data/classloader/\";\n\n    @Override\n    protected Class<?> findClass(String name) throws ClassNotFoundException {\n        String fileName = name.replaceAll(\"\\\\.\", \"/\");\n        fileName = BASE_DIR + fileName + \".class\";\n        try {\n            byte[] bytes = BinaryFileUtils.readFileToByteArray(fileName);\n            return defineClass(name, bytes, 0, bytes.length);\n        } catch (IOException ex) {\n            throw new ClassNotFoundException(\"failed to load class \" + name, ex);\n        }\n    }\n}\n```\n\n### 自定义了类加载器之后呢？能干嘛？\n\n- 可以创建多个MyClassLoader，对同一个类，每个MyClassLoader都可以加载一次，得到同一个类对不同Class对象\n- 可以实现隔离\n    - 不同模块使用不同的类加载器\n- 可以实现热部署\n    - 使用自定义类加载器，加载Class，得到的就是新的，从而可以实现动态更新\n\n### 热部署实验\n\n```java\npublic class HotDeployDemo {\n    /**\n     * 实现类名称\n     */\n    private static final String CLASS_NAME = \"com.kim.base.classloader.custom.HelloImpl\";\n    /**\n     * class文件路径\n     */\n    private static final String FILE_NAME = \"target/classes/\"\n            +CLASS_NAME.replaceAll(\"\\\\.\", \"/\")+\".class\";\n    /**\n     * IHelloService实现类\n     */\n    private static volatile IHelloService helloService;\n\n    public static IHelloService getHelloService() {\n        if (helloService != null) {\n            return helloService;\n        }\n        synchronized (HotDeployDemo.class) {\n            if (helloService == null) {\n                helloService = createHelloService();\n            }\n            return helloService;\n        }\n    }\n\n    /**\n     * 通过自定义类加载器，从指定的目录加载IHelloService实现类\n     * @return\n     */\n    private static IHelloService createHelloService() {\n        try {\n            MyClassLoader cl = new MyClassLoader();\n            Class<?> cls = cl.loadClass(CLASS_NAME);\n            if (cls != null) {\n                return (IHelloService) cls.newInstance();\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n    public static void client() {\n        Thread t = new Thread() {\n            @Override\n            public void run() {\n                try {\n                    while (true) {\n                        IHelloService helloService = getHelloService();\n                        helloService.sayHello();\n                        Thread.sleep(1000);\n                    }\n                } catch (InterruptedException e) {\n                }\n            }\n        };\n        t.start();\n    }\n\n    /**\n     * 一个监视文件变化的线程，文件如果变化了，就重新加载\n     */\n    public static void monitor() {\n        Thread t = new Thread() {\n            private long lastModified = new File(FILE_NAME).lastModified();\n\n            @Override\n            public void run() {\n                try {\n                    while (true) {\n                        Thread.sleep(100);\n                        long now = new File(FILE_NAME).lastModified();\n                        if (now != lastModified) {\n                            lastModified = now;\n                            reloadHelloService();\n                        }\n                    }\n                } catch (InterruptedException e) {\n                }\n            }\n        };\n        t.start();\n    }\n\n    public static void reloadHelloService() {\n        System.out.println(\"文件被修改了，重新加载\");\n        helloService = createHelloService();\n    }\n\n    public static void main(String[] args) {\n        monitor();\n        client();\n    }\n}\n```\n\n- 我们把创建HelloService的实现的方式提取出来，通过自定义类加载器，在指定目录加载他的实现\n- 我们使用一个线程，监听自定义类加载器加载类的地方，监听具体文件的变化，有变化就重新实例化一个自定义类加载器，加载新的类，使其生效\n- 模拟客户端调用\n    - 用一个线程，无限循环去调用helloServicve的方法sayHello\n\n## 总结\n\n通过类加载器的学习，我们知道了类加载器最起码可以做如下三样事情：\n\n1. 热部署\n2. 应用的模块化和隔离\n3. 从不同的地方灵活加载\n\n我们使用的tomcat就是使用类加载器的典型例子，通过案例和实验代码的运行、调试、理解，对类加载器的应用应该会有更深的理解，对tomcat的运行机制也不会觉得那么神秘。\n\n读者自己可以试试实现一个简单的tomcat，可以实现热部署、应用的隔离。\n\n","tags":["Java","类加载器"],"categories":["Java","ClassLoader"]},{"title":"我应该写什么","url":"/2021/02/08/我应该写什么/","content":"\n折腾了一天，重新把hexo博客建好了\n\n\n\n不想再折腾了\n\n\n\n打算要写的内容，计划用博客来做什么\n\n- 记录学习过程，主要记录读书笔记、思维导图的总结、教程的总结（Java、分布式微服务、数据存储、算法、中间件源码架构设计）\n- 记录排查问题的过程\n- 记录生活中的想法（旅游、带娃、生活习惯养成、运动）\n\n\n\n不该写的内容\n\n- 不该当作备忘录\n- 不写没有体系，不写技术、生活无关的内容\n\n\n\n博客应该具备的能力\n\n- 字数统计\n- 访问统计\n- 评论系统\n- 个人简介、经历（让别人认识你）\n\n\n\n接下来，把上面博客的能力实现，然后从Java、算法开始\n\n","tags":["Diary","Life"],"categories":["Diary","Life"]}]