[{"title":"动态代理","url":"/2021/02/14/动态代理/","content":"## 可以干什么\n\n- 可以在运行时动态创建一个类，实现一个或多个接口，可以在不修改原有类的基础上动态为通过该类获取的对象添加方法、修改行为（增强）\n- 动态代理是实现面向切面编程AOP的基础\n- AOP可以干什么？\n    - 日志、性能监控、权限检查、数据库事务\n    - AOP切面通过将切面逻辑和主体逻辑分离，使代码更优雅，对代码侵入低\n\n## 什么是代理\n\n和生活中的代理的意思类似。一般至少有一个实际对象，\n代理的外部功能和实际对象一般是一样的，用户与代理打交道，不直接接触实际对象。\n\n## 代理存在的价值\n\n- 节省成本，实际对象创建的成本开销大，按需延迟加载，\n  创建代理时并不真正创建实际对象，而只是保存实际对象的地址，在需要时再加载或创建\n- 执行权限检查，代理检查权限后，再调用实际对象\n- 屏蔽网络差异和复杂性，代理在本地，而实际对象在其他服务器上，调用本地代理时，本地代理请求其他服务器\n\n## 静态代理\n\n- 业务接口、实际类、代理类\n\n- 实际类实现业务接口，实现接口中的方法\n- 代理类也实现业务接口，并维持一个业务接口实现类的引用，通过构造函数注入实际类的引用，\n  实现的方法中实际调用的是实际类的方法\n    - 可以在调用实际方法的前后，做增强逻辑，比如在调用前后输出日志\n- 静态代理的代理类，是在写代码时就固定的，所以称为静态代理\n- 输出跟踪调试信息是一个通用需求，静态代理只能为某个类增强，要为某些类增强，只能每个类都写一个代理类，不现实。这就需要动态代理了。\n\n## 和适配器、装饰器的区别\n\n- 适配器\n    - 适配器提供了一个不一样的新接口\n- 装饰器\n    - 装饰器是对原接口起到了装饰的作用，可能增加了新接口、修改了原有的行为等，代理一般不改变接口\n\n我们不过于强调他们的差别，没有争论的意义，可以看作是代理的一种变体\n\n## 什么是动态代理\n\n代理类是运行时动态生成的。\n\n怎么动态生成？\n\n## 动态代理的两种方式\n\n### JDK提供的\n\n#### 实现InvocationHandler的接口，实现其invoke方法，这就是实现增强逻辑\n\ninvoke方法，三个参数\n\n- proxy，代理对象本身，一般不用\n- method，正在被调用的方法\n- args，表示方法的参数\n\n#### 怎么创建类\n\n通过Proxy.newProxyInstance，三个参数\n\n- classloader类加载器\n- 代理类要实现的接口列表\n- 实现增强逻辑的类，即实现InvocationHandler接口的类，对代理接口所有方法的调用都会转给该方法\n\n返回某个接口列表中的类型，只能强转为接口，不能是实现类\n\n\n\n#### 示例\n\n```java\npublic class SimpleJDKDynamicProxyDemo {\n    interface IService {\n        void sayHello();\n    }\n\n    static class RealService implements IService {\n\n        @Override\n        public void sayHello() {\n            System.out.println(\"hello\");\n        }\n    }\n\n    static class SimpleInvocationHandler implements InvocationHandler {\n        private Object realObj;\n\n        public SimpleInvocationHandler(Object realObj) {\n            this.realObj = realObj;\n        }\n\n        @Override\n        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n            System.out.println(\"entering \" + method.getName());\n            Object result = method.invoke(realObj, args);\n            System.out.println(\"leaving \" + method.getName());\n            return result;\n        }\n    }\n\n    public static void main(String[] args) {\n        IService realService = new RealService();\n        IService proxyService = (IService) Proxy.newProxyInstance(IService.class.getClassLoader(),\n                new Class<?>[] { IService.class }, new SimpleInvocationHandler(realService));\n        proxyService.sayHello();\n    }\n}\n```\n\n#### 基本原理\n\n上面例子生成的类如下：\n\n![](https://gitee.com/jinxin.70/oss/raw/master/uPic/DbDyLN_2021_02_07_15_28_27.png)\n\n生成的类是Proxy的子类，结合Proxy类看\n\n![](https://gitee.com/jinxin.70/oss/raw/master/uPic/HRFvbZ_2021_02_07_15_32_52.png)\n\n从上面可以看出，$Proxy0的构造方法传入InvocationHandler，最终赋值给父类Proxy的属性h，后续的其他方法调用都转发到这个InvocationHandler的子类中，比如，sayHello方法，调用的是this.h.invoke(this, m3, null);对于Object中的方法，如hashcode、equals和toString，$Proxy0同样转发给了InvocationHandler\n\n我们怎么知道$Proxy0的定义的呢？对于oracle的JVM，可以配置java的一个属性得到，比如\njava -Dsun.misc.ProxyGenerator.saveGeneratedFiles=true shuo.laoma.dynamic.c86.SimpleJDKDynamicProxyDemo\n\n以上命令会把动态生成的代理类$Proxy0保存到文件$Proxy0.class中，通过一些反编译器工具比如JD-GUI（http://jd.benow.ca）就可以得到源码。\n\n理解了代理类的定义，后面的代码就比较容易理解了，就是获取构造方法，创建代理对象\n\n#### 动态代理的优点\n\n不局限于某个类，可以为有相同需求的类实现切面逻辑\n\n#### JDK动态代理局限性\n\n只能为接口创建代理，返回的代理对象，也只能转换到某个接口类型\n\n\n### cglib\n\n可以为没有接口的类创建代理。\n\n#### 基本用法示例\n\n![](https://gitee.com/jinxin.70/oss/raw/master/uPic/RpCl6V_2021_02_07_16_10_18.png)\n\n- Enhancer类的setSuperclass设置被代理的类\n- setCallback设置被代理类的public非final方法被调用时的处理类\n- Enhancer类支持多种类型，这里使用的类实现了MethodInterceptor接口\n- 这里调用被代理类的方法只能是proxy.invokeSuper(object, args)，不能是method.invoke(object, args)\n\ncglib的实现机制，是通过**继承**实现的，动态创建一个类，但这个类的父类是被代理类，代理类重写了父类的所有public非final方法，改为调用Callback中的相关方法，在上例中，调用SimpleInterceptor的intercept方法。\n\n### JDK动态代理和cglib动态代理的比较\n\n- JDK动态代理面向一组接口，它为这些接口动态创建了一个实现类。\n    - 接口的具体实现逻辑是通过自定义的InvocationHandler实现的\n    - 这个实现是自定义的，也就是说，其背后都不一定有真正被代理的对象，也可能有多个实际对象，根据情况动态选择\n    - **代理的是对象，需要先有一个实际的对象**，自定义的InvocationHandler引用该对象，\n      然后创建一个代理类和代理对象，客户端访问的是代理对象，代理对象最后再调用实际对象的方法\n- cglib代理面向一个具体的类\n    - 动态创建一个新类，继承该类，重写其方法\n    - cglib代理的是类，创建的对象只有一个\n\n## 动态代理的应用——AOP\n\n实现原理\n\n[代码地址](https://gitee.com/jinxin.70/alpha1/tree/ce6dbb64df7848548723e9caa981ba6f371b2f0e/java-base/src/main/java/com/kim/base/proxy/aop)\n\n## 总结\n\n本文主要学习了动态代理，读完后应该知道这些内容\n\n- 什么是代理\n- 什么是静态代理？和适配器、装饰器模式的区别是什么\n- 为什么实际使用很少用静态代理\n- Java语言中动态代理的两种方式是什么？内部是如何去实现的？\n- 动态代理可以用来做什么？\n\n基本上是层层递进，到最后，动态代理的典型应用AOP，可以说是很多框架的基础，必须掌握其原理。","tags":["Java","动态代理"],"categories":["Java","动态代理"]},{"title":"选择排序","url":"/2021/02/12/selection-sort/","content":"\n## 排序过程\n\n假如对如下数组排序\n\n![image-20210212212637607](https://gitee.com/jinxin.70/oss/raw/master/uPic/image-20210212212637607_2021_02_12_21_26_37.png)\n\n我们打算从小到大排序\n\n### 第一轮\n\n先找到数组中最小的，是1\n\n![image-20210212212805249](https://gitee.com/jinxin.70/oss/raw/master/uPic/image-20210212212805249_2021_02_12_21_28_05.png)\n\n然后将1和数组中第一个位置上的数交换，这样，1就是最终的位置了\n\n![image-20210212212837283](https://gitee.com/jinxin.70/oss/raw/master/uPic/image-20210212212837283_2021_02_12_21_28_37.png)\n\n### 第二轮\n\n那么1排好了，我们从剩下的数里面找最小的数，是2\n\n![image-20210212212905854](https://gitee.com/jinxin.70/oss/raw/master/uPic/image-20210212212905854_2021_02_12_21_29_06.png)\n\n我们将2和第二个位置上的数交换位置\n\n![image-20210212213045447](https://gitee.com/jinxin.70/oss/raw/master/uPic/image-20210212213045447_2021_02_12_21_30_45.png)\n\n此时，1和2都已经固定好了位置\n\n![image-20210212213108930](https://gitee.com/jinxin.70/oss/raw/master/uPic/image-20210212213108930_2021_02_12_21_31_09.png)\n\n### 第三轮\n\n再从第三个位置往后找最小的数，然后与第三个位置上的数交换位置\n\n![image-20210212213214529](https://gitee.com/jinxin.70/oss/raw/master/uPic/image-20210212213214529_2021_02_12_21_32_14.png)\n\n![image-20210212213226904](https://gitee.com/jinxin.70/oss/raw/master/uPic/image-20210212213226904_2021_02_12_21_32_27.png)\n\n依此类推，找到数组末尾就排好序了\n\n### 第四轮\n\n![image-20210212213300337](https://gitee.com/jinxin.70/oss/raw/master/uPic/image-20210212213300337_2021_02_12_21_33_00.png)\n\n![image-20210212213317201](https://gitee.com/jinxin.70/oss/raw/master/uPic/image-20210212213317201_2021_02_12_21_33_17.png)\n\n### 第五轮\n\n![image-20210212213342282](https://gitee.com/jinxin.70/oss/raw/master/uPic/image-20210212213342282_2021_02_12_21_33_42.png)\n\n![image-20210212213355567](https://gitee.com/jinxin.70/oss/raw/master/uPic/image-20210212213355567_2021_02_12_21_33_55.png)\n\n### 第六轮\n\n![image-20210212213442090](https://gitee.com/jinxin.70/oss/raw/master/uPic/image-20210212213442090_2021_02_12_21_34_42.png)\n\n![image-20210212213453305](https://gitee.com/jinxin.70/oss/raw/master/uPic/image-20210212213453305_2021_02_12_21_34_53.png)\n\n### 第七轮\n\n![image-20210212213512606](https://gitee.com/jinxin.70/oss/raw/master/uPic/image-20210212213512606_2021_02_12_21_35_12.png)\n\n### 第八轮\n\n![image-20210212213535214](https://gitee.com/jinxin.70/oss/raw/master/uPic/image-20210212213535214_2021_02_12_21_35_35.png)\n\n## C++实现\n\n```c++\n#include <iostream>\n\nusing namespace std;\n/**\n * 选择排序\n * @param arr\n * @param n\n */\nvoid selectionSort(int arr[], int n){\n    for (int i = 0; i < n; ++i) {\n        //寻找[1,n)区间里的最小值\n        int minIndex = i;\n        for (int j = i + 1; j < n; ++j) {\n            if(arr[j] < arr[minIndex]){\n                minIndex = j;\n            }\n        }\n        swap(arr[i], arr[minIndex]);\n    }\n}\n\nint main(){\n    int a[10] = {10,9,8,7,6,5,4,3,2,1};\n    selectionSort(a, 10);\n\n    for (int i = 0; i < 10; ++i) {\n        cout<<a[i]<<\" \";\n    }\n    cout<<endl;\n    return 0;\n}\n```\n\n\n\n## 使用模板（范型）编写算法\n\n上面的实现，只能对int数组排序，我们需要对不同的类型排序，所以需要用到模板，有的语言叫范型。\n\n**Student.h**\n\n```c++\n\n#ifndef ALGORITHMCPLUSPLUS_STUDENT_H\n#define ALGORITHMCPLUSPLUS_STUDENT_H\n\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\nstruct Student{\n    string name;\n    int score;\n\n    // 重载小于运算法,定义Student之间的比较方式\n    // 如果分数相等，则按照名字的字母序排序\n    // 如果分数不等，则分数高的靠前\n    bool operator<(const Student& otherStudent){\n        return score != otherStudent.score ?\n               score > otherStudent.score : name < otherStudent.name;\n    }\n\n    // 重载<<符号, 定义Student实例的打印输出方式\n    // * 很多同学看到这里的C++语法, 头就大了, 甚至还有同学表示要重新学习C++语言\n    // * 对于这个课程, 大可不必。C++语言并不是这个课程的重点,\n    // * 大家也完全可以使用自己的方式书写代码, 最终只要能够打印出结果就好了, 比如设置一个成员函数, 叫做show()...\n    // * 推荐大家阅读我在问答区向大家分享的一个学习心得: 【学习心得分享】请大家抓大放小，不要纠结于C++语言的语法细节\n    // * 链接: http://coding.imooc.com/learn/questiondetail/4100.html\n    friend ostream& operator<<(ostream &os, const Student &student){\n\n        os<<\"Student: \"<<student.name<<\" \"<<student.score<<endl;\n        return os;\n    }\n};\n\n#endif //ALGORITHMCPLUSPLUS_STUDENT_H\n```\n\n**main.cpp**\n\n```c++\n#include <iostream>\n\nusing namespace std;\n#include \"Student.h\"\ntemplate<typename T>\n/**\n * 选择排序\n * @param arr\n * @param n\n */\nvoid selectionSort(T arr[], int n){\n    for (int i = 0; i < n; ++i) {\n        //寻找[1,n)区间里的最小值\n        int minIndex = i;\n        for (int j = i + 1; j < n; ++j) {\n            if(arr[j] < arr[minIndex]){\n                minIndex = j;\n            }\n        }\n        swap(arr[i], arr[minIndex]);\n    }\n}\n\nint main(){\n    int a[10] = {10,9,8,7,6,5,4,3,2,1};\n    selectionSort(a, 10);\n\n    for (int i = 0; i < 10; ++i) {\n        cout<<a[i]<<\" \";\n    }\n    cout<<endl;\n\n    float b[4] = {4.4,3.3,2.2,1.1};\n    selectionSort(b, 4);\n    for (int i = 0; i < 4; ++i) {\n        cout<<b[i]<< \" \";\n    }\n    cout<<endl;\n\n    string c[4] = {\"D\",\"C\",\"B\",\"A\"};\n    selectionSort(c,4);\n    for( int i = 0 ; i < 4 ; i ++ )\n        cout<<c[i]<<\" \";\n    cout<<endl;\n\n    Student d[4] = { {\"D\",90} , {\"C\",100} , {\"B\",95} , {\"A\",95} };\n    selectionSort(d,4);\n    for( int i = 0 ; i < 4 ; i ++ )\n        cout<<d[i];\n    cout<<endl;\n    return 0;\n}\n```\n\n## 随机生成算法测试用例（选学）\n\n思考🤔：\n\n我们上面代码的测试用例是硬编码的，我们希望生成自动生成。\n\n**SortTestHelper.h**\n\n```c++\n#ifndef ALGORITHMCPLUSPLUS_SORTTESTHELPER_H\n#define ALGORITHMCPLUSPLUS_SORTTESTHELPER_H\n#include <iostream>\n#include <ctime>\n#include <cassert>\n\nusing namespace std;\n\nnamespace SortTestHelper {\n// 生成有n个元素的随机数组,每个元素的随机范围为[rangeL, rangeR]\n    int *generateRandomArray(int n, int rangeL, int rangeR) {\n\n        assert(rangeL <= rangeR);\n\n        int *arr = new int[n];\n\n        srand(time(NULL));\n        for (int i = 0; i < n; i++)\n            arr[i] = rand() % (rangeR - rangeL + 1) + rangeL;\n        return arr;\n    }\n\n    // 打印arr数组的所有内容\n    template<typename T>\n    void printArray(T arr[], int n) {\n\n        for (int i = 0; i < n; i++)\n            cout << arr[i] << \" \";\n        cout << endl;\n\n        return;\n    }\n  // 判断arr数组是否有序\n    template<typename T>\n    bool isSorted(T arr[], int n) {\n\n        for (int i = 0; i < n - 1; i++)\n            if (arr[i] > arr[i + 1])\n                return false;\n\n        return true;\n    }\n\n    // 测试sort排序算法排序arr数组所得到结果的正确性和算法运行时间\n    // * 使用VS编码的同学, 对于函数指针的写法和调用方法可能和课程中介绍的有所不同;\n    // * 并且不同版本的VS, 其具体语法可能也有差异, 这是因为VS的编译器不完全是按照C++的标准实现的;\n    // * 本课程按照C++11的标准进行书写。对于VS编译器带来的语法差异, 希望同学们可以自己在网上查找相关资料解决;\n    // * 大家也可以在课程的官方QQ群中交流\n    // * 另外, 使用函数指针本身并不是这个课程的重点, 大家也完全可以使用自己的方式书写代码, 最终只要能够测试出自己书写的算法的效率即可\n    // * 推荐大家阅读我在问答区向大家分享的一个学习心得: 【学习心得分享】请大家抓大放小，不要纠结于C++语言的语法细节\n    // * 链接: http://coding.imooc.com/learn/questiondetail/4100.html\n    template<typename T>\n    void testSort(const string &sortName, void (*sort)(T[], int), T arr[], int n) {\n\n        clock_t startTime = clock();\n        sort(arr, n);\n        clock_t endTime = clock();\n\n        assert(isSorted(arr, n));\n        cout << sortName << \" : \" << double(endTime - startTime) / CLOCKS_PER_SEC << \" s\" << endl;\n//CLOCKS_PER_SEC表示每秒运行的时间周期数\n        return;\n    }\n};\n#endif //ALGORITHMCPLUSPLUS_SORTTESTHELPER_H\n```\n\ntestSort函数的入参void (*sort)(T[], int)是对一个函数的声明，其中\n\n- void 是返回值，表示返回void\n\n- *sort是函数指针\n\n- (T[], int)表示参数，T数组和int类型变量表示长度\n\n并且在函数声明上方要对T进行声明，template<typename T>\n\n**main.cpp**\n\n```c++\n#include <iostream>\n#include \"SortTestHelper.h\"\n\nusing namespace std;\n\ntemplate<typename T>\nvoid selectionSort(T arr[], int n){\n\n    for(int i = 0 ; i < n ; i ++){\n\n        int minIndex = i;\n        for( int j = i + 1 ; j < n ; j ++ )\n            if( arr[j] < arr[minIndex] )\n                minIndex = j;\n\n        swap( arr[i] , arr[minIndex] );\n    }\n}\n\nint main() {\n\n    // 测试排序算法辅助函数\n    int N = 20000;\n    int *arr = SortTestHelper::generateRandomArray(N,0,100000);\n    selectionSort(arr,N);\n    SortTestHelper::printArray(arr,N);\n    delete[] arr;\n\n    return 0;\n}\n```\n","tags":["算法","C++"],"categories":["Algorithm","C++"]},{"title":"类加载机制","url":"/2021/02/09/类加载机制/","content":"\n## 类加载器可以做什么\n\n### 热部署\n\n不重启Java程序的情况下，动态替换类的实现\n\n比如JSP、OSGI\n\n### 应用的模块化和隔离\n\n不同的类加载器可以加载相同的类，但互相隔离、互不影响\n\n比如：\n\n- Tomcat在一个程序中管理多个Web应用，每个Web应用有自己的classloader\n- OSGI和Java9实现动态模块化架构，每个模块有自己的ClassLoader\n\n### 可以从不同的地方灵活加载类\n\n## 为什么要学自定义classloader\n\n- 有助于我们理解相关的系统和框架，比如Tomcat\n- 在业务需要的时候，可以自定义classloader实现动态灵活的功能\n\n## 类加载的基本机制和过程\n\n首先了解下，JDK提供的几个类加载器\n\n- 启动类加载器。加载基础类，主要是rt.jar\n- 扩展类加载器。加载ext目录下的jar\n- 应用程序类加载器。加载应用程序的类，包括自己写的和引入的第三方法类库\n\n要点：类加载器之间的关系，不是继承关系，是委派关系。\n\n### 加载过程\n\n1. 判断类是否加载过了，没有就一层层向上委派给父类，最后先让启动类加载器加载\n2. 启动类加载到了，就返回Class对象，否则就让ext加载器加载\n3. ext加载器加载到了，就返回Class对象，否则就让应用类加载器加载\n4. 应用类加载器加载到了，就返回Class对象，否则返回抛异常\n\n上面的加载过程就是双亲委派，一个类加载时，委派给ext类加载器，再委派给启动类加载器\n\n这样可以避免Java基础类库被覆盖\n\nJDK允许不遵循上面的加载过程，打破双亲委派规则：\n\n- 自定义的加载顺序\n  - 即使不遵守双亲委派，以java开头的类也不能被自定义类加载器加载，这是由Java的安全机制保证的，以避免混乱。\n- 网状加载顺序\n  - OSGI和Java9模块化系统，类加载器之间的关系是一个网，每个模块有一个类加载器\n- 父加载器委派给子加载器加载\n  - JNDI服务\n\n## 理解ClassLoader\n\nClassLoader类是一个抽象类。\n\n有两个子类\n\n- AppClassLoader\n- ExtClassLoader\n\nBootstrapClassLoader并不是它的子类，BootstrapClassLoader是C++写的，用于加载java基础类的。\n\n### Class对象的API\n\n#### getClassLoader\n\ngetClassLoader获取ClassLoader，来看看ClassLoader的API\n\n- getParent\n  - 如果parent是Bootstrap ClassLoader，返回值为null\n- 静态方法getSystemClassLoader\n  - 获取默认的系统类机载器\n- loadeClass方法\n  - ![示例](https://gitee.com/jinxin.70/oss/raw/master/uPic2/VulpSW.png)\n- 深入loadClass方法\n  - ![](https://gitee.com/jinxin.70/oss/raw/master/uPic2/6HvGpS.png)\n\n#### Class.forName\n\n![](https://gitee.com/jinxin.70/oss/raw/master/uPic2/jqjhdq.png)\n\n- 第一个方法，使用系统类加载器加载\n- 第二个方法，指定ClassLoader，参数initialize表示加载后是否执行类的初始化代码（如static代码块），没有指定默认true。\n\nClass.forName和ClassLoader的loadClass方法都能加载类\n\n不同点：ClassLoader的loadClass方法不会执行类的初始化代码\n\n```java\npublic class CLInitDemo {\n    public static class Hello {\n        static {\n            System.out.println(\"hello\");\n        }\n    };\n\n    public static void main(String[] args) {\n        ClassLoader cl = ClassLoader.getSystemClassLoader();\n        String className = CLInitDemo.class.getName() + \"$Hello\";\n        try {\n            //不会初始化类，不会执行静态方法和代码块\n\t\t\tClass<?> cls = cl.loadClass(className);\n\t\t\t//会初始化类，会执行静态方法和静态代码块\n//            Class<?> cls = Class.forName(className);\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n## 类加载器的应用：可配置的策略\n\n策略模式，将不同策略实现类，配置在外部文件中，不同场合使用不同的配置，通过反射、类加载器加载配置中的类。不需要改代码就可以改变程序的行为\n\n[代码地址](https://gitee.com/jinxin.70/alpha1/commit/5fa782b61f350874eaa919c397fa21630911fb40)\n\n## 自定义ClassLoader\n\n### 一般步骤\n\n1. 继承ClassLoader\n2. 重写findClass\n    1. 从class文件位置加载类\n    2. 转成字节数组\n    3. 调用defineClass方法\n\n### 案例\n\n```java\npublic class MyClassLoader extends ClassLoader{\n    private static final String BASE_DIR = \"data/classloader/\";\n\n    @Override\n    protected Class<?> findClass(String name) throws ClassNotFoundException {\n        String fileName = name.replaceAll(\"\\\\.\", \"/\");\n        fileName = BASE_DIR + fileName + \".class\";\n        try {\n            byte[] bytes = BinaryFileUtils.readFileToByteArray(fileName);\n            return defineClass(name, bytes, 0, bytes.length);\n        } catch (IOException ex) {\n            throw new ClassNotFoundException(\"failed to load class \" + name, ex);\n        }\n    }\n}\n```\n\n### 自定义了类加载器之后呢？能干嘛？\n\n- 可以创建多个MyClassLoader，对同一个类，每个MyClassLoader都可以加载一次，得到同一个类对不同Class对象\n- 可以实现隔离\n    - 不同模块使用不同的类加载器\n- 可以实现热部署\n    - 使用自定义类加载器，加载Class，得到的就是新的，从而可以实现动态更新\n\n### 热部署实验\n\n```java\npublic class HotDeployDemo {\n    /**\n     * 实现类名称\n     */\n    private static final String CLASS_NAME = \"com.kim.base.classloader.custom.HelloImpl\";\n    /**\n     * class文件路径\n     */\n    private static final String FILE_NAME = \"target/classes/\"\n            +CLASS_NAME.replaceAll(\"\\\\.\", \"/\")+\".class\";\n    /**\n     * IHelloService实现类\n     */\n    private static volatile IHelloService helloService;\n\n    public static IHelloService getHelloService() {\n        if (helloService != null) {\n            return helloService;\n        }\n        synchronized (HotDeployDemo.class) {\n            if (helloService == null) {\n                helloService = createHelloService();\n            }\n            return helloService;\n        }\n    }\n\n    /**\n     * 通过自定义类加载器，从指定的目录加载IHelloService实现类\n     * @return\n     */\n    private static IHelloService createHelloService() {\n        try {\n            MyClassLoader cl = new MyClassLoader();\n            Class<?> cls = cl.loadClass(CLASS_NAME);\n            if (cls != null) {\n                return (IHelloService) cls.newInstance();\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n    public static void client() {\n        Thread t = new Thread() {\n            @Override\n            public void run() {\n                try {\n                    while (true) {\n                        IHelloService helloService = getHelloService();\n                        helloService.sayHello();\n                        Thread.sleep(1000);\n                    }\n                } catch (InterruptedException e) {\n                }\n            }\n        };\n        t.start();\n    }\n\n    /**\n     * 一个监视文件变化的线程，文件如果变化了，就重新加载\n     */\n    public static void monitor() {\n        Thread t = new Thread() {\n            private long lastModified = new File(FILE_NAME).lastModified();\n\n            @Override\n            public void run() {\n                try {\n                    while (true) {\n                        Thread.sleep(100);\n                        long now = new File(FILE_NAME).lastModified();\n                        if (now != lastModified) {\n                            lastModified = now;\n                            reloadHelloService();\n                        }\n                    }\n                } catch (InterruptedException e) {\n                }\n            }\n        };\n        t.start();\n    }\n\n    public static void reloadHelloService() {\n        System.out.println(\"文件被修改了，重新加载\");\n        helloService = createHelloService();\n    }\n\n    public static void main(String[] args) {\n        monitor();\n        client();\n    }\n}\n```\n\n- 我们把创建HelloService的实现的方式提取出来，通过自定义类加载器，在指定目录加载他的实现\n- 我们使用一个线程，监听自定义类加载器加载类的地方，监听具体文件的变化，有变化就重新实例化一个自定义类加载器，加载新的类，使其生效\n- 模拟客户端调用\n    - 用一个线程，无限循环去调用helloServicve的方法sayHello\n\n## 总结\n\n通过类加载器的学习，我们知道了类加载器最起码可以做如下三样事情：\n\n1. 热部署\n2. 应用的模块化和隔离\n3. 从不同的地方灵活加载\n\n我们使用的tomcat就是使用类加载器的典型例子，通过案例和实验代码的运行、调试、理解，对类加载器的应用应该会有更深的理解，对tomcat的运行机制也不会觉得那么神秘。\n\n读者自己可以试试实现一个简单的tomcat，可以实现热部署、应用的隔离。\n\n","tags":["Java","类加载器"],"categories":["Java","ClassLoader"]},{"title":"我应该写什么","url":"/2021/02/08/我应该写什么/","content":"\n折腾了一天，重新把hexo博客建好了\n\n\n\n不想再折腾了\n\n\n\n打算要写的内容，计划用博客来做什么\n\n- 记录学习过程，主要记录读书笔记、思维导图的总结、教程的总结（Java、分布式微服务、数据存储、算法、中间件源码架构设计）\n- 记录排查问题的过程\n- 记录生活中的想法（旅游、带娃、生活习惯养成、运动）\n\n\n\n不该写的内容\n\n- 不该当作备忘录\n- 不写没有体系，不写技术、生活无关的内容\n\n\n\n博客应该具备的能力\n\n- 字数统计\n- 访问统计\n- 评论系统\n- 个人简介、经历（让别人认识你）\n\n\n\n接下来，把上面博客的能力实现，然后从Java、算法开始\n\n","tags":["Diary","Life"],"categories":["Diary","Life"]}]