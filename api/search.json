[{"id":"31a861b85a2c5696a7a9b4dfe9060a08","title":"归并排序基础","content":"前要回顾前面我们学习了选择排序和插入排序，比较好理解，但是复杂度是O(n^2)\n不是说O(n^2)不好，在数据量不大的时候，其实是可以用的，因为实现简单。\n有没有更好的排序方案呢？\n下面看看时间复杂度是O(nlogn)的排序算法，归并排序。\n思路假如要对下面的数组排序\n\n归并排序的思路是：把数组对半分，想办法把左边的数组排序，把右半部分排序，最后合并。\n在排序左半部分时，再把左半部分在对半分，并排序，合并。\n\n这样对半分，分到最后，每一部分只有一个元素，就不能再分了，然后顺序也排好了，只需要每部分依此归并。\n时间复杂度分析我们看下分成了几层，\n\n总共有log(n)层。分析：每次对半分，分多少次？log以2为底，8的对数，是4。\n再以O(n)的算法归并，所以总体复杂度是O(nlogn)。\n实现技巧使用递归思想。\n需要开辟临时空间，辅助归并。\n使用三个索引对归并过程跟踪。\n\n蓝色的箭头，表示最终在归并的过程中我们需要跟踪的位置。\n两个红色的箭头指向两个排好序的数组当前我们要考虑的元素。\n归并排序过程我们考虑2，1谁应该先放到最终数组中\n\n1比2小，将1放入最终数组中，蓝色箭头移动到下一个位置\n\n与此同时，1原先所在数据的红色指针，考虑移动到下一个位置\n\n此时1已经在原数组中排好序了，\n在考虑2和4，2更小\n\n2放入原数组第二个位置，同时原数组的蓝色指针向后移一位，\n\n与此同时，2原来所在数组的红色指针，向后移到一个位置\n\n再考虑3和4，\n\n3比4小，3放入原数组的蓝色指针指向的位置，原数组蓝色指针向后移动一位\n\n与此同时，3所在原数组的红色指针，向后移动一位。\n\n此时比较6和4，4比6小，4放到原数组的蓝色指针指向的位置，原数组蓝色指针向后移动一位，同时4所在原数组的红色指针向后移动一位。\n\n\n指针就绪后，再考虑6和5比较，依此类推。\n难点使用了三个索引（指针），必须定义清楚。\n\n定义i和j，为当前正在考虑的元素，k用来指向i和j比较后，最终应该放到归并数组中的位置。\n注意，k表示的是下一个需要放置的位置，不是归并后的最后位置。\n维持三个变量在实现过程中，始终符合我们的定义，是正确实现的基础。\n为了防止越界，需要定义另外两个变量l(left)和r(right)，分别表示最左边和最右边的位置。\n\n还需要一个表示已经排好序的中间数组的最后一个位置m（middle）。\n\nC++实现main.cpp\n#include &lt;iostream&gt;\n#include &quot;SortTestHelper.h&quot;\n#include &quot;InsertionSort.h&quot;\n\nusing namespace std;\n\n\n&#x2F;&#x2F; 将arr[l...mid]和arr[mid+1...r]两部分进行归并\ntemplate&lt;typename  T&gt;\nvoid __merge(T arr[], int l, int mid, int r)&#123;\n\n    &#x2F;&#x2F;* VS不支持动态长度数组, 即不能使用 T aux[r-l+1]的方式申请aux的空间\n    &#x2F;&#x2F;* 使用VS的同学, 请使用new的方式申请aux空间\n    &#x2F;&#x2F;* 使用new申请空间, 不要忘了在__merge函数的最后, delete掉申请的空间:)\n\n    &#x2F;&#x2F;辅助空间对大小，由于是前闭后闭区间，所以是r-l+1\n    T aux[r-l+1];\n    &#x2F;&#x2F;T *aux &#x3D; new T[r-l+1];\n\n    &#x2F;&#x2F;临时空间初始化\n    for( int i &#x3D; l ; i &lt;&#x3D; r; i ++ )\n        &#x2F;&#x2F;aux是从零开始的，但是处理的arr空间是动态的l开始的，两个数组有一个l的距离偏移\n        aux[i-l] &#x3D; arr[i];\n\n    &#x2F;&#x2F; 初始化，i指向左半部分的起始索引位置l；j指向右半部分起始索引位置mid+1\n    int i &#x3D; l, j &#x3D; mid+1;\n    &#x2F;&#x2F;从l遍历到r，左边遍历到右边，决定k的位置\n    for( int k &#x3D; l ; k &lt;&#x3D; r; k ++ )&#123;\n\n        if( i &gt; mid )&#123;  &#x2F;&#x2F; 如果左半部分元素已经全部处理完毕\n            arr[k] &#x3D; aux[j-l]; j ++;\n        &#125;\n        else if( j &gt; r )&#123;  &#x2F;&#x2F; 如果右半部分元素已经全部处理完毕\n            arr[k] &#x3D; aux[i-l]; i ++;\n        &#125;\n        else if( aux[i-l] &lt; aux[j-l] ) &#123;  &#x2F;&#x2F; 左半部分所指元素 &lt; 右半部分所指元素\n            arr[k] &#x3D; aux[i-l]; i ++;\n        &#125;\n        else&#123;  &#x2F;&#x2F; 左半部分所指元素 &gt;&#x3D; 右半部分所指元素\n            arr[k] &#x3D; aux[j-l]; j ++;\n        &#125;\n    &#125;\n\n    &#x2F;&#x2F;delete[] aux;\n&#125;\n\n&#x2F;&#x2F; 递归使用归并排序,对arr[l...r]的范围进行排序\ntemplate&lt;typename T&gt;\nvoid __mergeSort(T arr[], int l, int r)&#123;\n\n    &#x2F;&#x2F;处理递归到底的情况，l&gt;&#x3D;r表示要处理的是至多一个元素的情况\n    if( l &gt;&#x3D; r )\n        return;\n\n    &#x2F;&#x2F;计算中点位置 思考：当l和r很大时，l+r可能会溢出，如何避免\n    int mid &#x3D; (l+r)&#x2F;2;\n    &#x2F;&#x2F;对一半进行归并排序\n    __mergeSort(arr, l, mid);\n    &#x2F;&#x2F;对另一半进行归并排序\n    __mergeSort(arr, mid+1, r);\n    &#x2F;&#x2F;合并上面对两半数据\n    __merge(arr, l, mid, r);\n&#125;\n\ntemplate&lt;typename T&gt;\nvoid mergeSort(T arr[], int n)&#123;\n\n    __mergeSort( arr , 0 , n-1 );\n&#125;\n\n\n&#x2F;&#x2F; 比较InsertionSort和MergeSort两种排序算法的性能效率\n&#x2F;&#x2F; 整体而言, MergeSort的性能最优, 对于近乎有序的数组的特殊情况, 见测试2的详细注释\nint main() &#123;\n\n    &#x2F;&#x2F; Merge Sort是我们学习的第一个O(nlogn)复杂度的算法\n    &#x2F;&#x2F; 可以在1秒之内轻松处理100万数量级的数据\n    &#x2F;&#x2F; 注意：不要轻易尝试使用SelectionSort, InsertionSort或者BubbleSort处理100万级的数据\n    &#x2F;&#x2F; 否则，你就见识了O(n^2)的算法和O(nlogn)算法的本质差异：）\n    int n &#x3D; 50000;\n\n    &#x2F;&#x2F; 测试1 一般性测试\n    cout&lt;&lt;&quot;Test for random array, size &#x3D; &quot;&lt;&lt;n&lt;&lt;&quot;, random range [0, &quot;&lt;&lt;n&lt;&lt;&quot;]&quot;&lt;&lt;endl;\n    int* arr1 &#x3D; SortTestHelper::generateRandomArray(n,0,n);\n    int* arr2 &#x3D; SortTestHelper::copyIntArray(arr1, n);\n\n    SortTestHelper::testSort(&quot;Insertion Sort&quot;, insertionSort, arr1, n);\n    SortTestHelper::testSort(&quot;Merge Sort&quot;,     mergeSort,     arr2, n);\n\n    delete[] arr1;\n    delete[] arr2;\n\n    cout&lt;&lt;endl;\n\n\n    &#x2F;&#x2F; 测试2 测试近乎有序的数组\n    &#x2F;&#x2F; 对于近乎有序的数组, 数组越有序, InsertionSort的时间性能越趋近于O(n)\n    &#x2F;&#x2F; 所以可以尝试, 当swapTimes比较大时, MergeSort更快\n    &#x2F;&#x2F; 但是当swapTimes小到一定程度, InsertionSort变得比MergeSort快\n    int swapTimes &#x3D; 10;\n    assert( swapTimes &gt;&#x3D; 0 );\n\n    cout&lt;&lt;&quot;Test for nearly ordered array, size &#x3D; &quot;&lt;&lt;n&lt;&lt;&quot;, swap time &#x3D; &quot;&lt;&lt;swapTimes&lt;&lt;endl;\n    arr1 &#x3D; SortTestHelper::generateNearlyOrderedArray(n,swapTimes);\n    arr2 &#x3D; SortTestHelper::copyIntArray(arr1, n);\n\n    SortTestHelper::testSort(&quot;Insertion Sort&quot;, insertionSort, arr1, n);\n    SortTestHelper::testSort(&quot;Merge Sort&quot;,     mergeSort,     arr2, n);\n\n    delete[] arr1;\n    delete[] arr2;\n\n    return 0;\n&#125;\n\n完整代码地址\n优化优化点一在数据基本有序的情况下，归并排序比插入排序性能还是差的。\n代码可以进一步优化，只有在arr[mid]&gt;arr[mid+1]时，才归并，否则已经从小到大排好了，就不必归并，从而在基本有序的时候减少排序操作。\n&#x2F;&#x2F;对一半进行归并排序\n    __mergeSort(arr, l, mid);\n    &#x2F;&#x2F;对另一半进行归并排序\n    __mergeSort(arr, mid+1, r);\n    if(arr[mid]&gt;arr[mid+1]) &#123;\n        &#x2F;&#x2F;合并上面对两半数据\n        __merge(arr, l, mid, r);\n    &#125;\n\n\n\n\n\n\n\n\n\n\n这里总结一下设计排序算法时，需要考虑的设计点：\n\n考虑是否要对近乎有序的数据进行排序\n\n优化点二在数据量小的时候，数组近乎有序的概率大，插入排序有优势；\n在数据量小的时候，插入排序是比归并排序快的。\n所以，可以进一步优化。\n&#x2F;&#x2F; 优化2: 对于小规模数组, 使用插入排序\n    if( r - l &lt;&#x3D; 15 )&#123;\n        insertionSort(arr, l, r);\n        return;\n    &#125;\n\n完整代码地址\n总结本小结介绍了归并排序算法\n\n归并排序是一种拆分合并的思路\n使用递归的技巧实现\n需要注意算法的实现过程中，使用到一些辅助的指针和临时空间\n归并排序的效率是O(nlogn)，但是在数据量不大时，插入排序效率更高\n在数组近乎有序的时候，可以做一点优化，减少归并次数\n\n","slug":"归并排序基础","date":"2021-03-22T14:18:33.000Z","categories_index":"Algorithm,C++","tags_index":"算法,C++","author_index":"Aurora"},{"id":"f2ea62009b2a302d5e2076e5efd27611","title":"插入排序","content":"前要回顾前面我们提供了一个对数据排序的方案，是选择排序。\n排序的过程，回顾一下。\n如果要对数组进行从小到大排序，选择排序怎么做呢？\n我们对数组的每个位置进行遍历，举个例子：\n比如一开始，第一个位置，我们要放置最小的元素到这个位置，于是从所有元素中选择一个最小的。然后和第一个位置的元素交换，这样，就确定了最小的数。\n下面确定第二小的数，就是从第一个位置后面所有的元素中找到最小的，然后交换位置。\n依此类推，完成从小到大的排序。\n这就是选择排序的一般过程。\n总体来看，需要两层循环去完成上述过程，第一层循环，用于确定每个位置上的应该存放的合适的数。\n第二层是在剩余未排序的元素中找到这个合适的数的位置。\n时间复杂度是O(n^2)\n除了选择排序，有没有其他的方案呢？\n有，再来看看插入排序，是另一种思路。\n插入排序假如要对下面的数组排序\n\n第一个元素8，不动，对于8，他是排好序的，继续下一个元素\n\n我们想要把第二个元素6，插入到前面元素的合适位置，\n\n6比8小，交换位置\n\n下面开始，将2插入到前面合适的位置，\n\n2和8比较，比8小，和8交换位置\n\n2再和6比，2比6小，交换位置\n\n下面开始，对3\n3依次比较前面的数，然后交换位置，直到找到合适的位置\n\n\n插入排序的原理，可以提前终止循环，原则上比选择排序快，但是请看下面的写法。\n插入排序代码for (int i &#x3D; 1; i &lt; n; ++i) &#123;\n\n        &#x2F;&#x2F;找到合适的位置插入\n&#x2F;&#x2F;        for (int j &#x3D; i; j &gt; 0; j--) &#123;\n&#x2F;&#x2F;            if(arr[j] &lt; arr[j-1])&#123;\n&#x2F;&#x2F;                swap(arr[j], arr[j-1]);\n&#x2F;&#x2F;            &#125;else&#123;\n&#x2F;&#x2F;                break;\n&#x2F;&#x2F;            &#125;\n&#x2F;&#x2F;        &#125;\n\n        &#x2F;&#x2F; 写法2\n        for( int j &#x3D; i ; j &gt; 0 &amp;&amp; arr[j] &lt; arr[j-1] ; j -- )\n            swap( arr[j] , arr[j-1] );\n    &#125;\n\n插入排序改进上面的swap交换操作比比较操作慢。我们是放在内层for循环里执行的，效率差。对比选择排序，我们通过比较找到要插入的位置，在外层循环插入，所以上面的插入排序的写法效率反而比选择排序慢。\n\n先复制一份6，判断6是不是适合当前位置\n\n发现6比8小，8应该在当前位置，把8向后移动一位\n\n然后比较6现在是不是应该在第一个位置，前面没有可比的元素了，所以把6赋值到第一个位置\n\n6、8此时排好序\n\n再考察2\n\n先复制一份2的副本\n\n2比前一个数8小，所以应该把8向后移动一位\n\n再向前比较，2和6比较，比6小，应该将6向后移动一位。\n\n此时2所在的位置，已经是第一个位置了，前面没有可比的元素，那么将2复制到第一个位置\n\n此时，2、6、8已经排好序，再看下一个位置的数3\n依然复制这个位置上的数3。\n\n依次和前面的数比较，如果比前面的数小，前面的数向后移动一位。\n\n\n\n\n和一开始的不同时，我们把一次次的交换操作改成了比较\ntemplate&lt;typename T&gt;\nvoid insertionSort(T arr[], int n)&#123;\n\n    for( int i &#x3D; 1 ; i &lt; n ; i ++ ) &#123;\n\n        &#x2F;&#x2F; 寻找元素arr[i]合适的插入位置\n        &#x2F;&#x2F; 写法1\n&#x2F;&#x2F;        for( int j &#x3D; i ; j &gt; 0 ; j-- )\n&#x2F;&#x2F;            if( arr[j] &lt; arr[j-1] )\n&#x2F;&#x2F;                swap( arr[j] , arr[j-1] );\n&#x2F;&#x2F;            else\n&#x2F;&#x2F;                break;\n\n        &#x2F;&#x2F; 写法2\n&#x2F;&#x2F;        for( int j &#x3D; i ; j &gt; 0 &amp;&amp; arr[j] &lt; arr[j-1] ; j -- )\n&#x2F;&#x2F;            swap( arr[j] , arr[j-1] );\n\n        &#x2F;&#x2F; 写法3\n        &#x2F;&#x2F;使用e保存每一次要处理的外层元素\n        T e &#x3D; arr[i];\n        int j; &#x2F;&#x2F; j保存元素e应该插入的位置\n        for (j &#x3D; i; j &gt; 0 &amp;&amp; arr[j-1] &gt; e; j--)\n            &#x2F;&#x2F;把前一个位置的元素向后移动一位\n            arr[j] &#x3D; arr[j-1];\n        &#x2F;&#x2F;将e放到合适的位置\n        arr[j] &#x3D; e;\n    &#125;\n\n    return;\n&#125;\n\n插入排序，在数组基本有序的情况下，效率非常高！\n选择排序和插入排序比较\n都是O(n^2)复杂度\n插入排序在数组近乎有序的时候，效率非常高\n\n为什么插入排序在数据近乎有序时，效率比选择排序高。\n因为选择排序，是从剩余位置找到最小的数，找最小数这个过程，要比较剩余的所有元素才能找到最小值\n插入排序，是把当前位置的元素和前面排好序的元素比较，找到一个合适的位置，由于前面是排好序的，\n所以在元素基本有序的情况下，插入比较不需要和前面所有元素比较，就能确定合适的位置。\n","slug":"插入排序","date":"2021-03-16T11:28:01.000Z","categories_index":"Algorithm,C++","tags_index":"算法,C++","author_index":"Aurora"},{"id":"6256a2c967d4226dbb5b05689bfb7d23","title":"MySQL联合索引和最左前缀原则理解一","content":"如果给 user 表中的 username pwd 字段创建了复合索引那么使用以下SQL 都是可以命中索引:\nselect username from user where username&#x3D;&#39;zhangsan&#39; and pwd &#x3D;&#39;axsedf1sd&#39;\n\nselect username from user where pwd &#x3D;&#39;axsedf1sd&#39; and username&#x3D;&#39;zhangsan&#39;\n\nselect username from user where username&#x3D;&#39;zhangsan&#39;\n\n但是使用\nselect username from user where pwd &#x3D;&#39;axsedf1sd&#39;\n\n是不能命中索引的。\n上面是从最左前缀索引这篇文章看到的\n为什么select username from user where pwd =&#39;axsedf1sd&#39; and username=&#39;zhangsan&#39;会走索引？因为mysql优化器对联合索引，等值条件、and条件有优化，会调整顺序。\n扩展：可以进一步看看优化器相关知识，更好的了解优化器的行为\nUsing where; Using index是什么意思？使用explain分析下面这个语句\nEXPLAIN select username from user where pwd &#x3D;&#39;axsedf1sd&#39;\n\n得到的结果如下：\n\n看到type是index，Extra是Using where; Using index\ntype是index表示什么意思？\n\n\n\n\n\n\n\n\ntype列表示存储引擎查询数据时采用的方式。比较重要的一个属性，通过它可以判断出查询是全表扫描还 是基于索引的部分扫描。常用属性值如下，从上至下效率依次增强。\n\nALL：表示全表扫描，性能最差。\nindex：表示基于索引的全表扫描，先扫描索引再扫描全表数据。\nrange：表示使用索引范围查询。使用&gt;、&gt;=、&lt;、&lt;=、in等等。\nref：表示使用非唯一索引进行单值查询。\neq_ref：一般情况下出现在多表join查询，表示前面表的每一个记录，都只能匹配后面表的一 行结果。\nconst：表示使用主键或唯一索引做等值查询，常量查询。\nNULL：表示不用访问表，速度最快。\n\n可以看到，type是index，效率不好\nUsing where; Using index是什么意思表示在索引树上包括要查找的列，但是不能按照顺序查找到，必须通过条件筛选\n什么是”走索引”？如果Extra只有Using index，表示索引树上有要查找的列，并且可以按照顺序查找到。也就是常说的”走索引”的意思\n总结\n常说的”走索引”，用explain分析后，Extra列的值是Using index，而Using where;Using index不走索引\n\nUsing where;Using index表示不走索引，索引树上能够扫描到要查找的列，但是不能按照顺序查找到，只能按照筛选条件查找\n\n“走索引”的意思是，要查找的列在索引树上可以扫描到，并且是可以按照索引顺序查找到。\n\n\n","slug":"最左前缀","date":"2021-03-11T08:45:25.000Z","categories_index":"MySQL,数据库","tags_index":"MySQL,数据库调优","author_index":"Aurora"},{"id":"6b9ce45aac70d77e5b13dbe67f0c2d3a","title":"动态代理","content":"可以干什么\n可以在运行时动态创建一个类，实现一个或多个接口，可以在不修改原有类的基础上动态为通过该类获取的对象添加方法、修改行为（增强）\n动态代理是实现面向切面编程AOP的基础\nAOP可以干什么？\n日志、性能监控、权限检查、数据库事务\nAOP切面通过将切面逻辑和主体逻辑分离，使代码更优雅，对代码侵入低\n\n\n\n什么是代理和生活中的代理的意思类似。一般至少有一个实际对象，代理的外部功能和实际对象一般是一样的，用户与代理打交道，不直接接触实际对象。\n代理存在的价值\n节省成本，实际对象创建的成本开销大，按需延迟加载，创建代理时并不真正创建实际对象，而只是保存实际对象的地址，在需要时再加载或创建\n执行权限检查，代理检查权限后，再调用实际对象\n屏蔽网络差异和复杂性，代理在本地，而实际对象在其他服务器上，调用本地代理时，本地代理请求其他服务器\n\n静态代理\n业务接口、实际类、代理类\n\n实际类实现业务接口，实现接口中的方法\n\n代理类也实现业务接口，并维持一个业务接口实现类的引用，通过构造函数注入实际类的引用，实现的方法中实际调用的是实际类的方法\n\n可以在调用实际方法的前后，做增强逻辑，比如在调用前后输出日志\n\n\n静态代理的代理类，是在写代码时就固定的，所以称为静态代理\n\n输出跟踪调试信息是一个通用需求，静态代理只能为某个类增强，要为某些类增强，只能每个类都写一个代理类，不现实。这就需要动态代理了。\n\n\n和适配器、装饰器的区别\n适配器\n适配器提供了一个不一样的新接口\n\n\n装饰器\n装饰器是对原接口起到了装饰的作用，可能增加了新接口、修改了原有的行为等，代理一般不改变接口\n\n\n\n我们不过于强调他们的差别，没有争论的意义，可以看作是代理的一种变体\n什么是动态代理代理类是运行时动态生成的。\n怎么动态生成？\n动态代理的两种方式JDK提供的实现InvocationHandler的接口，实现其invoke方法，这就是实现增强逻辑invoke方法，三个参数\n\nproxy，代理对象本身，一般不用\nmethod，正在被调用的方法\nargs，表示方法的参数\n\n怎么创建类通过Proxy.newProxyInstance，三个参数\n\nclassloader类加载器\n代理类要实现的接口列表\n实现增强逻辑的类，即实现InvocationHandler接口的类，对代理接口所有方法的调用都会转给该方法\n\n返回某个接口列表中的类型，只能强转为接口，不能是实现类\n示例public class SimpleJDKDynamicProxyDemo &#123;\n    interface IService &#123;\n        void sayHello();\n    &#125;\n\n    static class RealService implements IService &#123;\n\n        @Override\n        public void sayHello() &#123;\n            System.out.println(&quot;hello&quot;);\n        &#125;\n    &#125;\n\n    static class SimpleInvocationHandler implements InvocationHandler &#123;\n        private Object realObj;\n\n        public SimpleInvocationHandler(Object realObj) &#123;\n            this.realObj &#x3D; realObj;\n        &#125;\n\n        @Override\n        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;\n            System.out.println(&quot;entering &quot; + method.getName());\n            Object result &#x3D; method.invoke(realObj, args);\n            System.out.println(&quot;leaving &quot; + method.getName());\n            return result;\n        &#125;\n    &#125;\n\n    public static void main(String[] args) &#123;\n        IService realService &#x3D; new RealService();\n        IService proxyService &#x3D; (IService) Proxy.newProxyInstance(IService.class.getClassLoader(),\n                new Class&lt;?&gt;[] &#123; IService.class &#125;, new SimpleInvocationHandler(realService));\n        proxyService.sayHello();\n    &#125;\n&#125;\n\n基本原理上面例子生成的类如下：\n\n生成的类是Proxy的子类，结合Proxy类看\n\n从上面可以看出，$Proxy0的构造方法传入InvocationHandler，最终赋值给父类Proxy的属性h，后续的其他方法调用都转发到这个InvocationHandler的子类中，比如，sayHello方法，调用的是this.h.invoke(this, m3, null);对于Object中的方法，如hashcode、equals和toString，$Proxy0同样转发给了InvocationHandler\n我们怎么知道$Proxy0的定义的呢？对于oracle的JVM，可以配置java的一个属性得到，比如java -Dsun.misc.ProxyGenerator.saveGeneratedFiles=true shuo.laoma.dynamic.c86.SimpleJDKDynamicProxyDemo\n以上命令会把动态生成的代理类$Proxy0保存到文件$Proxy0.class中，通过一些反编译器工具比如JD-GUI（http://jd.benow.ca）就可以得到源码。\n理解了代理类的定义，后面的代码就比较容易理解了，就是获取构造方法，创建代理对象\n动态代理的优点不局限于某个类，可以为有相同需求的类实现切面逻辑\nJDK动态代理局限性只能为接口创建代理，返回的代理对象，也只能转换到某个接口类型\ncglib可以为没有接口的类创建代理。\n基本用法示例\n\nEnhancer类的setSuperclass设置被代理的类\nsetCallback设置被代理类的public非final方法被调用时的处理类\nEnhancer类支持多种类型，这里使用的类实现了MethodInterceptor接口\n这里调用被代理类的方法只能是proxy.invokeSuper(object, args)，不能是method.invoke(object, args)\n\ncglib的实现机制，是通过继承实现的，动态创建一个类，但这个类的父类是被代理类，代理类重写了父类的所有public非final方法，改为调用Callback中的相关方法，在上例中，调用SimpleInterceptor的intercept方法。\nJDK动态代理和cglib动态代理的比较\nJDK动态代理面向一组接口，它为这些接口动态创建了一个实现类。\n接口的具体实现逻辑是通过自定义的InvocationHandler实现的\n这个实现是自定义的，也就是说，其背后都不一定有真正被代理的对象，也可能有多个实际对象，根据情况动态选择\n代理的是对象，需要先有一个实际的对象，自定义的InvocationHandler引用该对象，然后创建一个代理类和代理对象，客户端访问的是代理对象，代理对象最后再调用实际对象的方法\n\n\ncglib代理面向一个具体的类\n动态创建一个新类，继承该类，重写其方法\ncglib代理的是类，创建的对象只有一个\n\n\n\n动态代理的应用——AOP实现原理\n代码地址\n总结本文主要学习了动态代理，读完后应该知道这些内容\n\n什么是代理\n什么是静态代理？和适配器、装饰器模式的区别是什么\n为什么实际使用很少用静态代理\nJava语言中动态代理的两种方式是什么？内部是如何去实现的？\n动态代理可以用来做什么？\n\n基本上是层层递进，到最后，动态代理的典型应用AOP，可以说是很多框架的基础，必须掌握其原理。\n","slug":"动态代理","date":"2021-02-14T08:16:34.000Z","categories_index":"Java,动态代理","tags_index":"Java,动态代理","author_index":"Aurora"},{"id":"25abdf87b37439d6db828d8a717bff02","title":"选择排序","content":"排序过程假如对如下数组排序\n\n我们打算从小到大排序\n第一轮先找到数组中最小的，是1\n\n然后将1和数组中第一个位置上的数交换，这样，1就是最终的位置了\n\n第二轮那么1排好了，我们从剩下的数里面找最小的数，是2\n\n我们将2和第二个位置上的数交换位置\n\n此时，1和2都已经固定好了位置\n\n第三轮再从第三个位置往后找最小的数，然后与第三个位置上的数交换位置\n\n\n依此类推，找到数组末尾就排好序了\n第四轮\n\n第五轮\n\n第六轮\n\n第七轮\n第八轮\nC++实现#include &lt;iostream&gt;\n\nusing namespace std;\n&#x2F;**\n * 选择排序\n * @param arr\n * @param n\n *&#x2F;\nvoid selectionSort(int arr[], int n)&#123;\n    for (int i &#x3D; 0; i &lt; n; ++i) &#123;\n        &#x2F;&#x2F;寻找[1,n)区间里的最小值\n        int minIndex &#x3D; i;\n        for (int j &#x3D; i + 1; j &lt; n; ++j) &#123;\n            if(arr[j] &lt; arr[minIndex])&#123;\n                minIndex &#x3D; j;\n            &#125;\n        &#125;\n        swap(arr[i], arr[minIndex]);\n    &#125;\n&#125;\n\nint main()&#123;\n    int a[10] &#x3D; &#123;10,9,8,7,6,5,4,3,2,1&#125;;\n    selectionSort(a, 10);\n\n    for (int i &#x3D; 0; i &lt; 10; ++i) &#123;\n        cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;\n    &#125;\n    cout&lt;&lt;endl;\n    return 0;\n&#125;\n\n\n\n使用模板（范型）编写算法上面的实现，只能对int数组排序，我们需要对不同的类型排序，所以需要用到模板，有的语言叫范型。\nStudent.h\n\n#ifndef ALGORITHMCPLUSPLUS_STUDENT_H\n#define ALGORITHMCPLUSPLUS_STUDENT_H\n\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nusing namespace std;\n\nstruct Student&#123;\n    string name;\n    int score;\n\n    &#x2F;&#x2F; 重载小于运算法,定义Student之间的比较方式\n    &#x2F;&#x2F; 如果分数相等，则按照名字的字母序排序\n    &#x2F;&#x2F; 如果分数不等，则分数高的靠前\n    bool operator&lt;(const Student&amp; otherStudent)&#123;\n        return score !&#x3D; otherStudent.score ?\n               score &gt; otherStudent.score : name &lt; otherStudent.name;\n    &#125;\n\n    &#x2F;&#x2F; 重载&lt;&lt;符号, 定义Student实例的打印输出方式\n    &#x2F;&#x2F; * 很多同学看到这里的C++语法, 头就大了, 甚至还有同学表示要重新学习C++语言\n    &#x2F;&#x2F; * 对于这个课程, 大可不必。C++语言并不是这个课程的重点,\n    &#x2F;&#x2F; * 大家也完全可以使用自己的方式书写代码, 最终只要能够打印出结果就好了, 比如设置一个成员函数, 叫做show()...\n    &#x2F;&#x2F; * 推荐大家阅读我在问答区向大家分享的一个学习心得: 【学习心得分享】请大家抓大放小，不要纠结于C++语言的语法细节\n    &#x2F;&#x2F; * 链接: http:&#x2F;&#x2F;coding.imooc.com&#x2F;learn&#x2F;questiondetail&#x2F;4100.html\n    friend ostream&amp; operator&lt;&lt;(ostream &amp;os, const Student &amp;student)&#123;\n\n        os&lt;&lt;&quot;Student: &quot;&lt;&lt;student.name&lt;&lt;&quot; &quot;&lt;&lt;student.score&lt;&lt;endl;\n        return os;\n    &#125;\n&#125;;\n\n#endif &#x2F;&#x2F;ALGORITHMCPLUSPLUS_STUDENT_H\n\nmain.cpp\n#include &lt;iostream&gt;\n\nusing namespace std;\n#include &quot;Student.h&quot;\ntemplate&lt;typename T&gt;\n&#x2F;**\n * 选择排序\n * @param arr\n * @param n\n *&#x2F;\nvoid selectionSort(T arr[], int n)&#123;\n    for (int i &#x3D; 0; i &lt; n; ++i) &#123;\n        &#x2F;&#x2F;寻找[1,n)区间里的最小值\n        int minIndex &#x3D; i;\n        for (int j &#x3D; i + 1; j &lt; n; ++j) &#123;\n            if(arr[j] &lt; arr[minIndex])&#123;\n                minIndex &#x3D; j;\n            &#125;\n        &#125;\n        swap(arr[i], arr[minIndex]);\n    &#125;\n&#125;\n\nint main()&#123;\n    int a[10] &#x3D; &#123;10,9,8,7,6,5,4,3,2,1&#125;;\n    selectionSort(a, 10);\n\n    for (int i &#x3D; 0; i &lt; 10; ++i) &#123;\n        cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;\n    &#125;\n    cout&lt;&lt;endl;\n\n    float b[4] &#x3D; &#123;4.4,3.3,2.2,1.1&#125;;\n    selectionSort(b, 4);\n    for (int i &#x3D; 0; i &lt; 4; ++i) &#123;\n        cout&lt;&lt;b[i]&lt;&lt; &quot; &quot;;\n    &#125;\n    cout&lt;&lt;endl;\n\n    string c[4] &#x3D; &#123;&quot;D&quot;,&quot;C&quot;,&quot;B&quot;,&quot;A&quot;&#125;;\n    selectionSort(c,4);\n    for( int i &#x3D; 0 ; i &lt; 4 ; i ++ )\n        cout&lt;&lt;c[i]&lt;&lt;&quot; &quot;;\n    cout&lt;&lt;endl;\n\n    Student d[4] &#x3D; &#123; &#123;&quot;D&quot;,90&#125; , &#123;&quot;C&quot;,100&#125; , &#123;&quot;B&quot;,95&#125; , &#123;&quot;A&quot;,95&#125; &#125;;\n    selectionSort(d,4);\n    for( int i &#x3D; 0 ; i &lt; 4 ; i ++ )\n        cout&lt;&lt;d[i];\n    cout&lt;&lt;endl;\n    return 0;\n&#125;\n\n随机生成算法测试用例（选学）思考🤔：\n我们上面代码的测试用例是硬编码的，我们希望生成自动生成。\nSortTestHelper.h\n#ifndef ALGORITHMCPLUSPLUS_SORTTESTHELPER_H\n#define ALGORITHMCPLUSPLUS_SORTTESTHELPER_H\n#include &lt;iostream&gt;\n#include &lt;ctime&gt;\n#include &lt;cassert&gt;\n\nusing namespace std;\n\nnamespace SortTestHelper &#123;\n&#x2F;&#x2F; 生成有n个元素的随机数组,每个元素的随机范围为[rangeL, rangeR]\n    int *generateRandomArray(int n, int rangeL, int rangeR) &#123;\n\n        assert(rangeL &lt;&#x3D; rangeR);\n\n        int *arr &#x3D; new int[n];\n\n        srand(time(NULL));\n        for (int i &#x3D; 0; i &lt; n; i++)\n            arr[i] &#x3D; rand() % (rangeR - rangeL + 1) + rangeL;\n        return arr;\n    &#125;\n\n    &#x2F;&#x2F; 打印arr数组的所有内容\n    template&lt;typename T&gt;\n    void printArray(T arr[], int n) &#123;\n\n        for (int i &#x3D; 0; i &lt; n; i++)\n            cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;;\n        cout &lt;&lt; endl;\n\n        return;\n    &#125;\n  &#x2F;&#x2F; 判断arr数组是否有序\n    template&lt;typename T&gt;\n    bool isSorted(T arr[], int n) &#123;\n\n        for (int i &#x3D; 0; i &lt; n - 1; i++)\n            if (arr[i] &gt; arr[i + 1])\n                return false;\n\n        return true;\n    &#125;\n\n    &#x2F;&#x2F; 测试sort排序算法排序arr数组所得到结果的正确性和算法运行时间\n    &#x2F;&#x2F; * 使用VS编码的同学, 对于函数指针的写法和调用方法可能和课程中介绍的有所不同;\n    &#x2F;&#x2F; * 并且不同版本的VS, 其具体语法可能也有差异, 这是因为VS的编译器不完全是按照C++的标准实现的;\n    &#x2F;&#x2F; * 本课程按照C++11的标准进行书写。对于VS编译器带来的语法差异, 希望同学们可以自己在网上查找相关资料解决;\n    &#x2F;&#x2F; * 大家也可以在课程的官方QQ群中交流\n    &#x2F;&#x2F; * 另外, 使用函数指针本身并不是这个课程的重点, 大家也完全可以使用自己的方式书写代码, 最终只要能够测试出自己书写的算法的效率即可\n    &#x2F;&#x2F; * 推荐大家阅读我在问答区向大家分享的一个学习心得: 【学习心得分享】请大家抓大放小，不要纠结于C++语言的语法细节\n    &#x2F;&#x2F; * 链接: http:&#x2F;&#x2F;coding.imooc.com&#x2F;learn&#x2F;questiondetail&#x2F;4100.html\n    template&lt;typename T&gt;\n    void testSort(const string &amp;sortName, void (*sort)(T[], int), T arr[], int n) &#123;\n\n        clock_t startTime &#x3D; clock();\n        sort(arr, n);\n        clock_t endTime &#x3D; clock();\n\n        assert(isSorted(arr, n));\n        cout &lt;&lt; sortName &lt;&lt; &quot; : &quot; &lt;&lt; double(endTime - startTime) &#x2F; CLOCKS_PER_SEC &lt;&lt; &quot; s&quot; &lt;&lt; endl;\n&#x2F;&#x2F;CLOCKS_PER_SEC表示每秒运行的时间周期数\n        return;\n    &#125;\n&#125;;\n#endif &#x2F;&#x2F;ALGORITHMCPLUSPLUS_SORTTESTHELPER_H\n\ntestSort函数的入参void (*sort)(T[], int)是对一个函数的声明，其中\n\nvoid 是返回值，表示返回void\n\n*sort是函数指针\n\n(T[], int)表示参数，T数组和int类型变量表示长度\n\n\n并且在函数声明上方要对T进行声明，template\nmain.cpp\n#include &lt;iostream&gt;\n#include &quot;SortTestHelper.h&quot;\n\nusing namespace std;\n\ntemplate&lt;typename T&gt;\nvoid selectionSort(T arr[], int n)&#123;\n\n    for(int i &#x3D; 0 ; i &lt; n ; i ++)&#123;\n\n        int minIndex &#x3D; i;\n        for( int j &#x3D; i + 1 ; j &lt; n ; j ++ )\n            if( arr[j] &lt; arr[minIndex] )\n                minIndex &#x3D; j;\n\n        swap( arr[i] , arr[minIndex] );\n    &#125;\n&#125;\n\nint main() &#123;\n\n    &#x2F;&#x2F; 测试排序算法辅助函数\n    int N &#x3D; 20000;\n    int *arr &#x3D; SortTestHelper::generateRandomArray(N,0,100000);\n    selectionSort(arr,N);\n    SortTestHelper::printArray(arr,N);\n    delete[] arr;\n\n    return 0;\n&#125;\n","slug":"selection-sort","date":"2021-02-12T14:33:00.000Z","categories_index":"Algorithm,C++","tags_index":"算法,C++","author_index":"Aurora"},{"id":"7749a2b5879f92c33b3cacbb2a610b9b","title":"类加载机制","content":"类加载器可以做什么热部署不重启Java程序的情况下，动态替换类的实现\n比如JSP、OSGI\n应用的模块化和隔离不同的类加载器可以加载相同的类，但互相隔离、互不影响\n比如：\n\nTomcat在一个程序中管理多个Web应用，每个Web应用有自己的classloader\nOSGI和Java9实现动态模块化架构，每个模块有自己的ClassLoader\n\n可以从不同的地方灵活加载类为什么要学自定义classloader\n有助于我们理解相关的系统和框架，比如Tomcat\n在业务需要的时候，可以自定义classloader实现动态灵活的功能\n\n类加载的基本机制和过程首先了解下，JDK提供的几个类加载器\n\n启动类加载器。加载基础类，主要是rt.jar\n扩展类加载器。加载ext目录下的jar\n应用程序类加载器。加载应用程序的类，包括自己写的和引入的第三方法类库\n\n要点：类加载器之间的关系，不是继承关系，是委派关系。\n加载过程\n判断类是否加载过了，没有就一层层向上委派给父类，最后先让启动类加载器加载\n启动类加载到了，就返回Class对象，否则就让ext加载器加载\next加载器加载到了，就返回Class对象，否则就让应用类加载器加载\n应用类加载器加载到了，就返回Class对象，否则返回抛异常\n\n上面的加载过程就是双亲委派，一个类加载时，委派给ext类加载器，再委派给启动类加载器\n这样可以避免Java基础类库被覆盖\nJDK允许不遵循上面的加载过程，打破双亲委派规则：\n\n自定义的加载顺序\n即使不遵守双亲委派，以java开头的类也不能被自定义类加载器加载，这是由Java的安全机制保证的，以避免混乱。\n\n\n网状加载顺序\nOSGI和Java9模块化系统，类加载器之间的关系是一个网，每个模块有一个类加载器\n\n\n父加载器委派给子加载器加载\nJNDI服务\n\n\n\n理解ClassLoaderClassLoader类是一个抽象类。\n有两个子类\n\nAppClassLoader\nExtClassLoader\n\nBootstrapClassLoader并不是它的子类，BootstrapClassLoader是C++写的，用于加载java基础类的。\nClass对象的APIgetClassLoadergetClassLoader获取ClassLoader，来看看ClassLoader的API\n\ngetParent\n如果parent是Bootstrap ClassLoader，返回值为null\n\n\n静态方法getSystemClassLoader\n获取默认的系统类机载器\n\n\nloadeClass方法\n\n\n\n深入loadClass方法\n\n\n\n\nClass.forName\n\n第一个方法，使用系统类加载器加载\n第二个方法，指定ClassLoader，参数initialize表示加载后是否执行类的初始化代码（如static代码块），没有指定默认true。\n\nClass.forName和ClassLoader的loadClass方法都能加载类\n不同点：ClassLoader的loadClass方法不会执行类的初始化代码\npublic class CLInitDemo &#123;\n    public static class Hello &#123;\n        static &#123;\n            System.out.println(&quot;hello&quot;);\n        &#125;\n    &#125;;\n\n    public static void main(String[] args) &#123;\n        ClassLoader cl &#x3D; ClassLoader.getSystemClassLoader();\n        String className &#x3D; CLInitDemo.class.getName() + &quot;$Hello&quot;;\n        try &#123;\n            &#x2F;&#x2F;不会初始化类，不会执行静态方法和代码块\n\t\t\tClass&lt;?&gt; cls &#x3D; cl.loadClass(className);\n\t\t\t&#x2F;&#x2F;会初始化类，会执行静态方法和静态代码块\n&#x2F;&#x2F;            Class&lt;?&gt; cls &#x3D; Class.forName(className);\n        &#125; catch (ClassNotFoundException e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;\n\n类加载器的应用：可配置的策略策略模式，将不同策略实现类，配置在外部文件中，不同场合使用不同的配置，通过反射、类加载器加载配置中的类。不需要改代码就可以改变程序的行为\n代码地址\n自定义ClassLoader一般步骤\n继承ClassLoader\n重写findClass\n从class文件位置加载类\n转成字节数组\n调用defineClass方法\n\n\n\n案例public class MyClassLoader extends ClassLoader&#123;\n    private static final String BASE_DIR &#x3D; &quot;data&#x2F;classloader&#x2F;&quot;;\n\n    @Override\n    protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;\n        String fileName &#x3D; name.replaceAll(&quot;\\\\.&quot;, &quot;&#x2F;&quot;);\n        fileName &#x3D; BASE_DIR + fileName + &quot;.class&quot;;\n        try &#123;\n            byte[] bytes &#x3D; BinaryFileUtils.readFileToByteArray(fileName);\n            return defineClass(name, bytes, 0, bytes.length);\n        &#125; catch (IOException ex) &#123;\n            throw new ClassNotFoundException(&quot;failed to load class &quot; + name, ex);\n        &#125;\n    &#125;\n&#125;\n\n自定义了类加载器之后呢？能干嘛？\n可以创建多个MyClassLoader，对同一个类，每个MyClassLoader都可以加载一次，得到同一个类对不同Class对象\n可以实现隔离\n不同模块使用不同的类加载器\n\n\n可以实现热部署\n使用自定义类加载器，加载Class，得到的就是新的，从而可以实现动态更新\n\n\n\n热部署实验public class HotDeployDemo &#123;\n    &#x2F;**\n     * 实现类名称\n     *&#x2F;\n    private static final String CLASS_NAME &#x3D; &quot;com.kim.base.classloader.custom.HelloImpl&quot;;\n    &#x2F;**\n     * class文件路径\n     *&#x2F;\n    private static final String FILE_NAME &#x3D; &quot;target&#x2F;classes&#x2F;&quot;\n            +CLASS_NAME.replaceAll(&quot;\\\\.&quot;, &quot;&#x2F;&quot;)+&quot;.class&quot;;\n    &#x2F;**\n     * IHelloService实现类\n     *&#x2F;\n    private static volatile IHelloService helloService;\n\n    public static IHelloService getHelloService() &#123;\n        if (helloService !&#x3D; null) &#123;\n            return helloService;\n        &#125;\n        synchronized (HotDeployDemo.class) &#123;\n            if (helloService &#x3D;&#x3D; null) &#123;\n                helloService &#x3D; createHelloService();\n            &#125;\n            return helloService;\n        &#125;\n    &#125;\n\n    &#x2F;**\n     * 通过自定义类加载器，从指定的目录加载IHelloService实现类\n     * @return\n     *&#x2F;\n    private static IHelloService createHelloService() &#123;\n        try &#123;\n            MyClassLoader cl &#x3D; new MyClassLoader();\n            Class&lt;?&gt; cls &#x3D; cl.loadClass(CLASS_NAME);\n            if (cls !&#x3D; null) &#123;\n                return (IHelloService) cls.newInstance();\n            &#125;\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125;\n        return null;\n    &#125;\n\n    public static void client() &#123;\n        Thread t &#x3D; new Thread() &#123;\n            @Override\n            public void run() &#123;\n                try &#123;\n                    while (true) &#123;\n                        IHelloService helloService &#x3D; getHelloService();\n                        helloService.sayHello();\n                        Thread.sleep(1000);\n                    &#125;\n                &#125; catch (InterruptedException e) &#123;\n                &#125;\n            &#125;\n        &#125;;\n        t.start();\n    &#125;\n\n    &#x2F;**\n     * 一个监视文件变化的线程，文件如果变化了，就重新加载\n     *&#x2F;\n    public static void monitor() &#123;\n        Thread t &#x3D; new Thread() &#123;\n            private long lastModified &#x3D; new File(FILE_NAME).lastModified();\n\n            @Override\n            public void run() &#123;\n                try &#123;\n                    while (true) &#123;\n                        Thread.sleep(100);\n                        long now &#x3D; new File(FILE_NAME).lastModified();\n                        if (now !&#x3D; lastModified) &#123;\n                            lastModified &#x3D; now;\n                            reloadHelloService();\n                        &#125;\n                    &#125;\n                &#125; catch (InterruptedException e) &#123;\n                &#125;\n            &#125;\n        &#125;;\n        t.start();\n    &#125;\n\n    public static void reloadHelloService() &#123;\n        System.out.println(&quot;文件被修改了，重新加载&quot;);\n        helloService &#x3D; createHelloService();\n    &#125;\n\n    public static void main(String[] args) &#123;\n        monitor();\n        client();\n    &#125;\n&#125;\n\n\n我们把创建HelloService的实现的方式提取出来，通过自定义类加载器，在指定目录加载他的实现\n我们使用一个线程，监听自定义类加载器加载类的地方，监听具体文件的变化，有变化就重新实例化一个自定义类加载器，加载新的类，使其生效\n模拟客户端调用\n用一个线程，无限循环去调用helloServicve的方法sayHello\n\n\n\n总结通过类加载器的学习，我们知道了类加载器最起码可以做如下三样事情：\n\n热部署\n应用的模块化和隔离\n从不同的地方灵活加载\n\n我们使用的tomcat就是使用类加载器的典型例子，通过案例和实验代码的运行、调试、理解，对类加载器的应用应该会有更深的理解，对tomcat的运行机制也不会觉得那么神秘。\n读者自己可以试试实现一个简单的tomcat，可以实现热部署、应用的隔离。\n","slug":"类加载机制","date":"2021-02-09T12:58:16.000Z","categories_index":"Java,ClassLoader","tags_index":"Java,类加载器","author_index":"Aurora"},{"id":"a07ffd4c9309478a5fb940206e09d98f","title":"我应该写什么","content":"折腾了一天，重新把hexo博客建好了\n不想再折腾了\n打算要写的内容，计划用博客来做什么\n\n记录学习过程，主要记录读书笔记、思维导图的总结、教程的总结（Java、分布式微服务、数据存储、算法、中间件源码架构设计）\n记录排查问题的过程\n记录生活中的想法（旅游、带娃、生活习惯养成、运动）\n\n不该写的内容\n\n不该当作备忘录\n不写没有体系，不写技术、生活无关的内容\n\n博客应该具备的能力\n\n字数统计\n访问统计\n评论系统\n个人简介、经历（让别人认识你）\n\n接下来，把上面博客的能力实现，然后从Java、算法开始\n","slug":"我应该写什么","date":"2021-02-08T08:44:58.000Z","categories_index":"Diary,Life","tags_index":"Diary,Life","author_index":"Aurora"}]