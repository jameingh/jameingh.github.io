{"name":"Algorithm","slug":"Algorithm","count":3,"postlist":[{"title":"选择排序","uid":"25abdf87b37439d6db828d8a717bff02","slug":"selection-sort","date":"2021-02-12T14:33:00.000Z","updated":"2021-12-04T13:07:53.309Z","comments":true,"path":"api/articles/selection-sort.json","keywords":"博客,后端,Java,算法,分布式,微服务,架构,业务开发,数据库,中间件,敏捷,管理,DDD,领域驱动设计,设计模式,搜索,消息队列","cover":[],"text":"排序过程假如对如下数组排序 我们打算从小到大排序 第一轮先找到数组中最小的，是1 然后将1和数组中第一个位置上的数交换，这样，1就是最终的位置了 第二轮那么1排好了，我们从剩下的数里面找最小的数，是2 我们将2和第二个位置上的数交换位置 此时，1和2都已经固定好了位置 第三轮再从...","link":"","photos":[],"count_time":{"symbolsCount":"6.9k","symbolsTime":"6 mins."},"categories":[{"name":"Algorithm","slug":"Algorithm","count":3,"path":"api/categories/Algorithm.json"},{"name":"C++","slug":"C","count":3,"path":"api/categories/C.json"}],"tags":[{"name":"算法","slug":"算法","count":3,"path":"api/tags/算法.json"},{"name":"C++","slug":"C","count":3,"path":"api/tags/C.json"}],"author":{"name":"Aurora","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"归并排序基础","uid":"31a861b85a2c5696a7a9b4dfe9060a08","slug":"归并排序基础","date":"2021-03-22T14:18:33.000Z","updated":"2021-12-04T13:07:53.310Z","comments":true,"path":"api/articles/归并排序基础.json","keywords":"博客,后端,Java,算法,分布式,微服务,架构,业务开发,数据库,中间件,敏捷,管理,DDD,领域驱动设计,设计模式,搜索,消息队列","cover":[],"text":"前要回顾前面我们学习了选择排序和插入排序，比较好理解，但是复杂度是O(n^2) 不是说O(n^2)不好，在数据量不大的时候，其实是可以用的，因为实现简单。 有没有更好的排序方案呢？ 下面看看时间复杂度是O(nlogn)的排序算法，归并排序。 思路假如要对下面的数组排序 归并排序的...","link":"","photos":[],"count_time":{"symbolsCount":"5.5k","symbolsTime":"5 mins."},"categories":[{"name":"Algorithm","slug":"Algorithm","count":3,"path":"api/categories/Algorithm.json"},{"name":"C++","slug":"C","count":3,"path":"api/categories/C.json"}],"tags":[{"name":"算法","slug":"算法","count":3,"path":"api/tags/算法.json"},{"name":"C++","slug":"C","count":3,"path":"api/tags/C.json"}],"author":{"name":"Aurora","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},{"title":"插入排序","uid":"f2ea62009b2a302d5e2076e5efd27611","slug":"插入排序","date":"2021-03-16T11:28:01.000Z","updated":"2021-12-04T13:07:53.310Z","comments":true,"path":"api/articles/插入排序.json","keywords":"博客,后端,Java,算法,分布式,微服务,架构,业务开发,数据库,中间件,敏捷,管理,DDD,领域驱动设计,设计模式,搜索,消息队列","cover":[],"text":"前要回顾前面我们提供了一个对数据排序的方案，是选择排序。 排序的过程，回顾一下。 如果要对数组进行从小到大排序，选择排序怎么做呢？ 我们对数组的每个位置进行遍历，举个例子： 比如一开始，第一个位置，我们要放置最小的元素到这个位置，于是从所有元素中选择一个最小的。然后和第一个位置的...","link":"","photos":[],"count_time":{"symbolsCount":"2.7k","symbolsTime":"2 mins."},"categories":[{"name":"Algorithm","slug":"Algorithm","count":3,"path":"api/categories/Algorithm.json"},{"name":"C++","slug":"C","count":3,"path":"api/categories/C.json"}],"tags":[{"name":"算法","slug":"算法","count":3,"path":"api/tags/算法.json"},{"name":"C++","slug":"C","count":3,"path":"api/tags/C.json"}],"author":{"name":"Aurora","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}]}