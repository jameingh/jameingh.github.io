{"title":"插入排序","uid":"f2ea62009b2a302d5e2076e5efd27611","slug":"插入排序","date":"2021-03-16T11:28:01.000Z","updated":"2023-10-18T01:53:17.946Z","comments":true,"path":"api/articles/插入排序.json","keywords":"博客,后端,Java,算法,分布式,微服务,架构,业务开发,数据库,中间件,敏捷,管理,DDD,领域驱动设计,设计模式,搜索,消息队列","cover":[],"content":"<h2 id=\"前要回顾\"><a href=\"#前要回顾\" class=\"headerlink\" title=\"前要回顾\"></a>前要回顾</h2><p>前面我们提供了一个对数据排序的方案，是选择排序。</p>\n<p>排序的过程，回顾一下。</p>\n<p>如果要对数组进行从小到大排序，选择排序怎么做呢？</p>\n<p>我们对数组的每个位置进行遍历，举个例子：</p>\n<p>比如一开始，第一个位置，我们要放置最小的元素到这个位置，于是从所有元素中选择一个最小的。然后和第一个位置的元素交换，这样，就确定了最小的数。</p>\n<p>下面确定第二小的数，就是从第一个位置后面所有的元素中找到最小的，然后交换位置。</p>\n<p>依此类推，完成从小到大的排序。</p>\n<p>这就是选择排序的一般过程。</p>\n<p>总体来看，需要两层循环去完成上述过程，第一层循环，用于确定每个位置上的应该存放的合适的数。</p>\n<p>第二层是在剩余未排序的元素中找到这个合适的数的位置。</p>\n<p>时间复杂度是O(n^2)</p>\n<p>除了选择排序，有没有其他的方案呢？</p>\n<p>有，再来看看插入排序，是另一种思路。</p>\n<h2 id=\"插入排序\"><a href=\"#插入排序\" class=\"headerlink\" title=\"插入排序\"></a>插入排序</h2><p>假如要对下面的数组排序</p>\n<p><img src=\"https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20210310184137684.png\" alt=\"image-20210310184137684\"></p>\n<p>第一个元素8，不动，对于8，他是排好序的，继续下一个元素</p>\n<p><img src=\"https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20210310184203449.png\" alt=\"image-20210310184203449\"></p>\n<p>我们想要把第二个元素6，插入到前面元素的合适位置，</p>\n<p><img src=\"https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20210310184421990.png\" alt=\"image-20210310184421990\"></p>\n<p>6比8小，交换位置</p>\n<p><img src=\"https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20210310184642749.png\" alt=\"image-20210310184642749\"></p>\n<p>下面开始，将2插入到前面合适的位置，</p>\n<p><img src=\"https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20210310184711464.png\" alt=\"image-20210310184711464\"></p>\n<p>2和8比较，比8小，和8交换位置</p>\n<p><img src=\"https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20210310184747973.png\" alt=\"image-20210310184747973\"></p>\n<p>2再和6比，2比6小，交换位置</p>\n<p><img src=\"https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20210310184816861.png\" alt=\"image-20210310184816861\"></p>\n<p>下面开始，对3</p>\n<p>3依次比较前面的数，然后交换位置，直到找到合适的位置</p>\n<p><img src=\"https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20210311000858595.png\" alt=\"image-20210311000858595\"></p>\n<p><img src=\"https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20210311000911306.png\" alt=\"image-20210311000911306\"></p>\n<p>插入排序的原理，可以提前终止循环，原则上比选择排序快，但是请看下面的写法。</p>\n<h2 id=\"插入排序代码\"><a href=\"#插入排序代码\" class=\"headerlink\" title=\"插入排序代码\"></a>插入排序代码</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">for (int i &#x3D; 1; i &lt; n; ++i) &#123;\n\n        &#x2F;&#x2F;找到合适的位置插入\n&#x2F;&#x2F;        for (int j &#x3D; i; j &gt; 0; j--) &#123;\n&#x2F;&#x2F;            if(arr[j] &lt; arr[j-1])&#123;\n&#x2F;&#x2F;                swap(arr[j], arr[j-1]);\n&#x2F;&#x2F;            &#125;else&#123;\n&#x2F;&#x2F;                break;\n&#x2F;&#x2F;            &#125;\n&#x2F;&#x2F;        &#125;\n\n        &#x2F;&#x2F; 写法2\n        for( int j &#x3D; i ; j &gt; 0 &amp;&amp; arr[j] &lt; arr[j-1] ; j -- )\n            swap( arr[j] , arr[j-1] );\n    &#125;</code></pre>\n\n<h2 id=\"插入排序改进\"><a href=\"#插入排序改进\" class=\"headerlink\" title=\"插入排序改进\"></a>插入排序改进</h2><p>上面的swap交换操作比比较操作慢。我们是放在内层for循环里执行的，效率差。对比选择排序，我们通过比较找到要插入的位置，在外层循环插入，所以上面的插入排序的写法效率反而比选择排序慢。</p>\n<p><img src=\"https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20210316190740449.png\" alt=\"image-20210316190740449\"></p>\n<p>先复制一份6，判断6是不是适合当前位置</p>\n<p><img src=\"https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20210316190934269.png\" alt=\"image-20210316190934269\"></p>\n<p>发现6比8小，8应该在当前位置，把8向后移动一位</p>\n<p><img src=\"https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20210316191027875.png\" alt=\"image-20210316191027875\"></p>\n<p>然后比较6现在是不是应该在第一个位置，前面没有可比的元素了，所以把6赋值到第一个位置</p>\n<p><img src=\"https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20210316191117718.png\" alt=\"image-20210316191117718\"></p>\n<p>6、8此时排好序</p>\n<p><img src=\"https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20210316191137953.png\" alt=\"image-20210316191137953\"></p>\n<p>再考察2</p>\n<p><img src=\"https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20210316191156617.png\" alt=\"image-20210316191156617\"></p>\n<p>先复制一份2的副本</p>\n<p><img src=\"https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20210316191214977.png\" alt=\"image-20210316191214977\"></p>\n<p>2比前一个数8小，所以应该把8向后移动一位</p>\n<p><img src=\"https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20210316191303808.png\" alt=\"image-20210316191303808\"></p>\n<p>再向前比较，2和6比较，比6小，应该将6向后移动一位。</p>\n<p><img src=\"https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20210316191344992.png\" alt=\"image-20210316191344992\"></p>\n<p>此时2所在的位置，已经是第一个位置了，前面没有可比的元素，那么将2复制到第一个位置</p>\n<p><img src=\"https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20210316191429779.png\" alt=\"image-20210316191429779\"></p>\n<p>此时，2、6、8已经排好序，再看下一个位置的数3</p>\n<p>依然复制这个位置上的数3。</p>\n<p><img src=\"https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20210316191502735.png\" alt=\"image-20210316191502735\"></p>\n<p>依次和前面的数比较，如果比前面的数小，前面的数向后移动一位。</p>\n<p><img src=\"https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20210316191603847.png\" alt=\"image-20210316191603847\"></p>\n<p><img src=\"https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20210316191617319.png\" alt=\"image-20210316191617319\"></p>\n<p><img src=\"https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20210316191627434.png\" alt=\"image-20210316191627434\"></p>\n<p><img src=\"https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20210316191636169.png\" alt=\"image-20210316191636169\"></p>\n<p><strong>和一开始的不同时，我们把一次次的交换操作改成了比较</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">template&lt;typename T&gt;\nvoid insertionSort(T arr[], int n)&#123;\n\n    for( int i &#x3D; 1 ; i &lt; n ; i ++ ) &#123;\n\n        &#x2F;&#x2F; 寻找元素arr[i]合适的插入位置\n        &#x2F;&#x2F; 写法1\n&#x2F;&#x2F;        for( int j &#x3D; i ; j &gt; 0 ; j-- )\n&#x2F;&#x2F;            if( arr[j] &lt; arr[j-1] )\n&#x2F;&#x2F;                swap( arr[j] , arr[j-1] );\n&#x2F;&#x2F;            else\n&#x2F;&#x2F;                break;\n\n        &#x2F;&#x2F; 写法2\n&#x2F;&#x2F;        for( int j &#x3D; i ; j &gt; 0 &amp;&amp; arr[j] &lt; arr[j-1] ; j -- )\n&#x2F;&#x2F;            swap( arr[j] , arr[j-1] );\n\n        &#x2F;&#x2F; 写法3\n        &#x2F;&#x2F;使用e保存每一次要处理的外层元素\n        T e &#x3D; arr[i];\n        int j; &#x2F;&#x2F; j保存元素e应该插入的位置\n        for (j &#x3D; i; j &gt; 0 &amp;&amp; arr[j-1] &gt; e; j--)\n            &#x2F;&#x2F;把前一个位置的元素向后移动一位\n            arr[j] &#x3D; arr[j-1];\n        &#x2F;&#x2F;将e放到合适的位置\n        arr[j] &#x3D; e;\n    &#125;\n\n    return;\n&#125;</code></pre>\n\n<p>插入排序，<strong>在数组基本有序的情况下，效率非常高！</strong></p>\n<h2 id=\"选择排序和插入排序比较\"><a href=\"#选择排序和插入排序比较\" class=\"headerlink\" title=\"选择排序和插入排序比较\"></a>选择排序和插入排序比较</h2><ul>\n<li>都是O(n^2)复杂度</li>\n<li>插入排序在数组近乎有序的时候，效率非常高</li>\n</ul>\n<p>为什么插入排序在数据近乎有序时，效率比选择排序高。</p>\n<p>因为选择排序，是从剩余位置找到最小的数，找最小数这个过程，要比较剩余的所有元素才能找到最小值</p>\n<p>插入排序，是把当前位置的元素和前面排好序的元素比较，找到一个合适的位置，由于前面是排好序的，</p>\n<p>所以在元素基本有序的情况下，插入比较不需要和前面所有元素比较，就能确定合适的位置。</p>\n","feature":true,"text":"前要回顾前面我们提供了一个对数据排序的方案，是选择排序。 排序的过程，回顾一下。 如果要对数组进行从小到大排序，选择排序怎么做呢？ 我们对数组的每个位置进行遍历，举个例子： 比如一开始，第一个位置，我们要放置最小的元素到这个位置，于是从所有元素中选择一个最小的。然后和第一个位置的...","link":"","photos":[],"count_time":{"symbolsCount":"2.7k","symbolsTime":"2 mins."},"categories":[{"name":"Algorithm","slug":"Algorithm","count":3,"path":"api/categories/Algorithm.json"},{"name":"C++","slug":"C","count":3,"path":"api/categories/C.json"}],"tags":[{"name":"算法","slug":"算法","count":3,"path":"api/tags/算法.json"},{"name":"C++","slug":"C","count":3,"path":"api/tags/C.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%89%8D%E8%A6%81%E5%9B%9E%E9%A1%BE\"><span class=\"toc-text\">前要回顾</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">插入排序</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E4%BB%A3%E7%A0%81\"><span class=\"toc-text\">插入排序代码</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E6%94%B9%E8%BF%9B\"><span class=\"toc-text\">插入排序改进</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E5%92%8C%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E6%AF%94%E8%BE%83\"><span class=\"toc-text\">选择排序和插入排序比较</span></a></li></ol>","author":{"name":"Aurora","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"归并排序基础","uid":"31a861b85a2c5696a7a9b4dfe9060a08","slug":"归并排序基础","date":"2021-03-22T14:18:33.000Z","updated":"2023-10-18T01:53:17.946Z","comments":true,"path":"api/articles/归并排序基础.json","keywords":"博客,后端,Java,算法,分布式,微服务,架构,业务开发,数据库,中间件,敏捷,管理,DDD,领域驱动设计,设计模式,搜索,消息队列","cover":[],"text":"前要回顾前面我们学习了选择排序和插入排序，比较好理解，但是复杂度是O(n^2) 不是说O(n^2)不好，在数据量不大的时候，其实是可以用的，因为实现简单。 有没有更好的排序方案呢？ 下面看看时间复杂度是O(nlogn)的排序算法，归并排序。 思路假如要对下面的数组排序 归并排序的...","link":"","photos":[],"count_time":{"symbolsCount":"5.5k","symbolsTime":"5 mins."},"categories":[{"name":"Algorithm","slug":"Algorithm","count":3,"path":"api/categories/Algorithm.json"},{"name":"C++","slug":"C","count":3,"path":"api/categories/C.json"}],"tags":[{"name":"算法","slug":"算法","count":3,"path":"api/tags/算法.json"},{"name":"C++","slug":"C","count":3,"path":"api/tags/C.json"}],"author":{"name":"Aurora","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"MySQL联合索引和最左前缀原则理解一","uid":"6256a2c967d4226dbb5b05689bfb7d23","slug":"最左前缀","date":"2021-03-11T08:45:25.000Z","updated":"2023-10-18T01:53:17.946Z","comments":true,"path":"api/articles/最左前缀.json","keywords":"博客,后端,Java,算法,分布式,微服务,架构,业务开发,数据库,中间件,敏捷,管理,DDD,领域驱动设计,设计模式,搜索,消息队列","cover":[],"text":"如果给 user 表中的 username pwd 字段创建了复合索引那么使用以下SQL 都是可以命中索引: select username from user where username&#x3D;&#39;zhangsan&#39; and pwd &#x3D;&#39;a...","link":"","photos":[],"count_time":{"symbolsCount":"1.4k","symbolsTime":"1 mins."},"categories":[{"name":"MySQL","slug":"MySQL","count":1,"path":"api/categories/MySQL.json"},{"name":"数据库","slug":"数据库","count":1,"path":"api/categories/数据库.json"}],"tags":[{"name":"MySQL","slug":"MySQL","count":1,"path":"api/tags/MySQL.json"},{"name":"数据库调优","slug":"数据库调优","count":1,"path":"api/tags/数据库调优.json"}],"author":{"name":"Aurora","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}