{"title":"动态代理","uid":"6b9ce45aac70d77e5b13dbe67f0c2d3a","slug":"动态代理","date":"2021-02-14T08:16:34.000Z","updated":"2021-12-04T13:07:53.309Z","comments":true,"path":"api/articles/动态代理.json","keywords":"博客,后端,Java,算法,分布式,微服务,架构,业务开发,数据库,中间件,敏捷,管理,DDD,领域驱动设计,设计模式,搜索,消息队列","cover":[],"content":"<h2 id=\"可以干什么\"><a href=\"#可以干什么\" class=\"headerlink\" title=\"可以干什么\"></a>可以干什么</h2><ul>\n<li>可以在运行时动态创建一个类，实现一个或多个接口，可以在不修改原有类的基础上动态为通过该类获取的对象添加方法、修改行为（增强）</li>\n<li>动态代理是实现面向切面编程AOP的基础</li>\n<li>AOP可以干什么？<ul>\n<li>日志、性能监控、权限检查、数据库事务</li>\n<li>AOP切面通过将切面逻辑和主体逻辑分离，使代码更优雅，对代码侵入低</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"什么是代理\"><a href=\"#什么是代理\" class=\"headerlink\" title=\"什么是代理\"></a>什么是代理</h2><p>和生活中的代理的意思类似。一般至少有一个实际对象，<br>代理的外部功能和实际对象一般是一样的，用户与代理打交道，不直接接触实际对象。</p>\n<h2 id=\"代理存在的价值\"><a href=\"#代理存在的价值\" class=\"headerlink\" title=\"代理存在的价值\"></a>代理存在的价值</h2><ul>\n<li>节省成本，实际对象创建的成本开销大，按需延迟加载，<br>创建代理时并不真正创建实际对象，而只是保存实际对象的地址，在需要时再加载或创建</li>\n<li>执行权限检查，代理检查权限后，再调用实际对象</li>\n<li>屏蔽网络差异和复杂性，代理在本地，而实际对象在其他服务器上，调用本地代理时，本地代理请求其他服务器</li>\n</ul>\n<h2 id=\"静态代理\"><a href=\"#静态代理\" class=\"headerlink\" title=\"静态代理\"></a>静态代理</h2><ul>\n<li><p>业务接口、实际类、代理类</p>\n</li>\n<li><p>实际类实现业务接口，实现接口中的方法</p>\n</li>\n<li><p>代理类也实现业务接口，并维持一个业务接口实现类的引用，通过构造函数注入实际类的引用，<br>实现的方法中实际调用的是实际类的方法</p>\n<ul>\n<li>可以在调用实际方法的前后，做增强逻辑，比如在调用前后输出日志</li>\n</ul>\n</li>\n<li><p>静态代理的代理类，是在写代码时就固定的，所以称为静态代理</p>\n</li>\n<li><p>输出跟踪调试信息是一个通用需求，静态代理只能为某个类增强，要为某些类增强，只能每个类都写一个代理类，不现实。这就需要动态代理了。</p>\n</li>\n</ul>\n<h2 id=\"和适配器、装饰器的区别\"><a href=\"#和适配器、装饰器的区别\" class=\"headerlink\" title=\"和适配器、装饰器的区别\"></a>和适配器、装饰器的区别</h2><ul>\n<li>适配器<ul>\n<li>适配器提供了一个不一样的新接口</li>\n</ul>\n</li>\n<li>装饰器<ul>\n<li>装饰器是对原接口起到了装饰的作用，可能增加了新接口、修改了原有的行为等，代理一般不改变接口</li>\n</ul>\n</li>\n</ul>\n<p>我们不过于强调他们的差别，没有争论的意义，可以看作是代理的一种变体</p>\n<h2 id=\"什么是动态代理\"><a href=\"#什么是动态代理\" class=\"headerlink\" title=\"什么是动态代理\"></a>什么是动态代理</h2><p>代理类是运行时动态生成的。</p>\n<p>怎么动态生成？</p>\n<h2 id=\"动态代理的两种方式\"><a href=\"#动态代理的两种方式\" class=\"headerlink\" title=\"动态代理的两种方式\"></a>动态代理的两种方式</h2><h3 id=\"JDK提供的\"><a href=\"#JDK提供的\" class=\"headerlink\" title=\"JDK提供的\"></a>JDK提供的</h3><h4 id=\"实现InvocationHandler的接口，实现其invoke方法，这就是实现增强逻辑\"><a href=\"#实现InvocationHandler的接口，实现其invoke方法，这就是实现增强逻辑\" class=\"headerlink\" title=\"实现InvocationHandler的接口，实现其invoke方法，这就是实现增强逻辑\"></a>实现InvocationHandler的接口，实现其invoke方法，这就是实现增强逻辑</h4><p>invoke方法，三个参数</p>\n<ul>\n<li>proxy，代理对象本身，一般不用</li>\n<li>method，正在被调用的方法</li>\n<li>args，表示方法的参数</li>\n</ul>\n<h4 id=\"怎么创建类\"><a href=\"#怎么创建类\" class=\"headerlink\" title=\"怎么创建类\"></a>怎么创建类</h4><p>通过Proxy.newProxyInstance，三个参数</p>\n<ul>\n<li>classloader类加载器</li>\n<li>代理类要实现的接口列表</li>\n<li>实现增强逻辑的类，即实现InvocationHandler接口的类，对代理接口所有方法的调用都会转给该方法</li>\n</ul>\n<p>返回某个接口列表中的类型，只能强转为接口，不能是实现类</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class SimpleJDKDynamicProxyDemo &#123;\n    interface IService &#123;\n        void sayHello();\n    &#125;\n\n    static class RealService implements IService &#123;\n\n        @Override\n        public void sayHello() &#123;\n            System.out.println(&quot;hello&quot;);\n        &#125;\n    &#125;\n\n    static class SimpleInvocationHandler implements InvocationHandler &#123;\n        private Object realObj;\n\n        public SimpleInvocationHandler(Object realObj) &#123;\n            this.realObj &#x3D; realObj;\n        &#125;\n\n        @Override\n        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;\n            System.out.println(&quot;entering &quot; + method.getName());\n            Object result &#x3D; method.invoke(realObj, args);\n            System.out.println(&quot;leaving &quot; + method.getName());\n            return result;\n        &#125;\n    &#125;\n\n    public static void main(String[] args) &#123;\n        IService realService &#x3D; new RealService();\n        IService proxyService &#x3D; (IService) Proxy.newProxyInstance(IService.class.getClassLoader(),\n                new Class&lt;?&gt;[] &#123; IService.class &#125;, new SimpleInvocationHandler(realService));\n        proxyService.sayHello();\n    &#125;\n&#125;</code></pre>\n\n<h4 id=\"基本原理\"><a href=\"#基本原理\" class=\"headerlink\" title=\"基本原理\"></a>基本原理</h4><p>上面例子生成的类如下：</p>\n<p><img src=\"https://gitee.com/jinxin.70/oss/raw/master/uPic/DbDyLN_2021_02_07_15_28_27.png\"></p>\n<p>生成的类是Proxy的子类，结合Proxy类看</p>\n<p><img src=\"https://gitee.com/jinxin.70/oss/raw/master/uPic/HRFvbZ_2021_02_07_15_32_52.png\"></p>\n<p>从上面可以看出，$Proxy0的构造方法传入InvocationHandler，最终赋值给父类Proxy的属性h，后续的其他方法调用都转发到这个InvocationHandler的子类中，比如，sayHello方法，调用的是this.h.invoke(this, m3, null);对于Object中的方法，如hashcode、equals和toString，$Proxy0同样转发给了InvocationHandler</p>\n<p>我们怎么知道$Proxy0的定义的呢？对于oracle的JVM，可以配置java的一个属性得到，比如<br>java -Dsun.misc.ProxyGenerator.saveGeneratedFiles=true shuo.laoma.dynamic.c86.SimpleJDKDynamicProxyDemo</p>\n<p>以上命令会把动态生成的代理类$Proxy0保存到文件$Proxy0.class中，通过一些反编译器工具比如JD-GUI（<a href=\"http://jd.benow.ca)就可以得到源码./\">http://jd.benow.ca）就可以得到源码。</a></p>\n<p>理解了代理类的定义，后面的代码就比较容易理解了，就是获取构造方法，创建代理对象</p>\n<h4 id=\"动态代理的优点\"><a href=\"#动态代理的优点\" class=\"headerlink\" title=\"动态代理的优点\"></a>动态代理的优点</h4><p>不局限于某个类，可以为有相同需求的类实现切面逻辑</p>\n<h4 id=\"JDK动态代理局限性\"><a href=\"#JDK动态代理局限性\" class=\"headerlink\" title=\"JDK动态代理局限性\"></a>JDK动态代理局限性</h4><p>只能为接口创建代理，返回的代理对象，也只能转换到某个接口类型</p>\n<h3 id=\"cglib\"><a href=\"#cglib\" class=\"headerlink\" title=\"cglib\"></a>cglib</h3><p>可以为没有接口的类创建代理。</p>\n<h4 id=\"基本用法示例\"><a href=\"#基本用法示例\" class=\"headerlink\" title=\"基本用法示例\"></a>基本用法示例</h4><p><img src=\"https://gitee.com/jinxin.70/oss/raw/master/uPic/RpCl6V_2021_02_07_16_10_18.png\"></p>\n<ul>\n<li>Enhancer类的setSuperclass设置被代理的类</li>\n<li>setCallback设置被代理类的public非final方法被调用时的处理类</li>\n<li>Enhancer类支持多种类型，这里使用的类实现了MethodInterceptor接口</li>\n<li>这里调用被代理类的方法只能是proxy.invokeSuper(object, args)，不能是method.invoke(object, args)</li>\n</ul>\n<p>cglib的实现机制，是通过<strong>继承</strong>实现的，动态创建一个类，但这个类的父类是被代理类，代理类重写了父类的所有public非final方法，改为调用Callback中的相关方法，在上例中，调用SimpleInterceptor的intercept方法。</p>\n<h3 id=\"JDK动态代理和cglib动态代理的比较\"><a href=\"#JDK动态代理和cglib动态代理的比较\" class=\"headerlink\" title=\"JDK动态代理和cglib动态代理的比较\"></a>JDK动态代理和cglib动态代理的比较</h3><ul>\n<li>JDK动态代理面向一组接口，它为这些接口动态创建了一个实现类。<ul>\n<li>接口的具体实现逻辑是通过自定义的InvocationHandler实现的</li>\n<li>这个实现是自定义的，也就是说，其背后都不一定有真正被代理的对象，也可能有多个实际对象，根据情况动态选择</li>\n<li><strong>代理的是对象，需要先有一个实际的对象</strong>，自定义的InvocationHandler引用该对象，<br>然后创建一个代理类和代理对象，客户端访问的是代理对象，代理对象最后再调用实际对象的方法</li>\n</ul>\n</li>\n<li>cglib代理面向一个具体的类<ul>\n<li>动态创建一个新类，继承该类，重写其方法</li>\n<li>cglib代理的是类，创建的对象只有一个</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"动态代理的应用——AOP\"><a href=\"#动态代理的应用——AOP\" class=\"headerlink\" title=\"动态代理的应用——AOP\"></a>动态代理的应用——AOP</h2><p>实现原理</p>\n<p><a href=\"https://gitee.com/jinxin.70/alpha1/tree/ce6dbb64df7848548723e9caa981ba6f371b2f0e/java-base/src/main/java/com/kim/base/proxy/aop\">代码地址</a></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>本文主要学习了动态代理，读完后应该知道这些内容</p>\n<ul>\n<li>什么是代理</li>\n<li>什么是静态代理？和适配器、装饰器模式的区别是什么</li>\n<li>为什么实际使用很少用静态代理</li>\n<li>Java语言中动态代理的两种方式是什么？内部是如何去实现的？</li>\n<li>动态代理可以用来做什么？</li>\n</ul>\n<p>基本上是层层递进，到最后，动态代理的典型应用AOP，可以说是很多框架的基础，必须掌握其原理。</p>\n","text":"可以干什么 可以在运行时动态创建一个类，实现一个或多个接口，可以在不修改原有类的基础上动态为通过该类获取的对象添加方法、修改行为（增强） 动态代理是实现面向切面编程AOP的基础 AOP可以干什么？ 日志、性能监控、权限检查、数据库事务 AOP切面通过将切面逻辑和主体逻辑分离，使代...","link":"","photos":[],"count_time":{"symbolsCount":"3.7k","symbolsTime":"3 mins."},"categories":[{"name":"Java","slug":"Java","count":2,"path":"api/categories/Java.json"},{"name":"动态代理","slug":"动态代理","count":1,"path":"api/categories/动态代理.json"}],"tags":[{"name":"Java","slug":"Java","count":2,"path":"api/tags/Java.json"},{"name":"动态代理","slug":"动态代理","count":1,"path":"api/tags/动态代理.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%AF%E4%BB%A5%E5%B9%B2%E4%BB%80%E4%B9%88\"><span class=\"toc-text\">可以干什么</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E4%BB%A3%E7%90%86\"><span class=\"toc-text\">什么是代理</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%A3%E7%90%86%E5%AD%98%E5%9C%A8%E7%9A%84%E4%BB%B7%E5%80%BC\"><span class=\"toc-text\">代理存在的价值</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86\"><span class=\"toc-text\">静态代理</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%92%8C%E9%80%82%E9%85%8D%E5%99%A8%E3%80%81%E8%A3%85%E9%A5%B0%E5%99%A8%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">和适配器、装饰器的区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86\"><span class=\"toc-text\">什么是动态代理</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">动态代理的两种方式</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#JDK%E6%8F%90%E4%BE%9B%E7%9A%84\"><span class=\"toc-text\">JDK提供的</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E7%8E%B0InvocationHandler%E7%9A%84%E6%8E%A5%E5%8F%A3%EF%BC%8C%E5%AE%9E%E7%8E%B0%E5%85%B6invoke%E6%96%B9%E6%B3%95%EF%BC%8C%E8%BF%99%E5%B0%B1%E6%98%AF%E5%AE%9E%E7%8E%B0%E5%A2%9E%E5%BC%BA%E9%80%BB%E8%BE%91\"><span class=\"toc-text\">实现InvocationHandler的接口，实现其invoke方法，这就是实现增强逻辑</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%80%8E%E4%B9%88%E5%88%9B%E5%BB%BA%E7%B1%BB\"><span class=\"toc-text\">怎么创建类</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">示例</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">基本原理</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E4%BC%98%E7%82%B9\"><span class=\"toc-text\">动态代理的优点</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%B1%80%E9%99%90%E6%80%A7\"><span class=\"toc-text\">JDK动态代理局限性</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#cglib\"><span class=\"toc-text\">cglib</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">基本用法示例</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8Ccglib%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E6%AF%94%E8%BE%83\"><span class=\"toc-text\">JDK动态代理和cglib动态代理的比较</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E5%BA%94%E7%94%A8%E2%80%94%E2%80%94AOP\"><span class=\"toc-text\">动态代理的应用——AOP</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a></li></ol>","author":{"name":"Aurora","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"MySQL联合索引和最左前缀原则理解一","uid":"6256a2c967d4226dbb5b05689bfb7d23","slug":"最左前缀","date":"2021-03-11T08:45:25.000Z","updated":"2021-12-04T13:07:53.310Z","comments":true,"path":"api/articles/最左前缀.json","keywords":"博客,后端,Java,算法,分布式,微服务,架构,业务开发,数据库,中间件,敏捷,管理,DDD,领域驱动设计,设计模式,搜索,消息队列","cover":[],"text":"如果给 user 表中的 username pwd 字段创建了复合索引那么使用以下SQL 都是可以命中索引: select username from user where username&#x3D;&#39;zhangsan&#39; and pwd &#x3D;&#39;a...","link":"","photos":[],"count_time":{"symbolsCount":"1.4k","symbolsTime":"1 mins."},"categories":[{"name":"MySQL","slug":"MySQL","count":1,"path":"api/categories/MySQL.json"},{"name":"数据库","slug":"数据库","count":1,"path":"api/categories/数据库.json"}],"tags":[{"name":"MySQL","slug":"MySQL","count":1,"path":"api/tags/MySQL.json"},{"name":"数据库调优","slug":"数据库调优","count":1,"path":"api/tags/数据库调优.json"}],"author":{"name":"Aurora","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"选择排序","uid":"25abdf87b37439d6db828d8a717bff02","slug":"selection-sort","date":"2021-02-12T14:33:00.000Z","updated":"2021-12-04T13:07:53.309Z","comments":true,"path":"api/articles/selection-sort.json","keywords":"博客,后端,Java,算法,分布式,微服务,架构,业务开发,数据库,中间件,敏捷,管理,DDD,领域驱动设计,设计模式,搜索,消息队列","cover":[],"text":"排序过程假如对如下数组排序 我们打算从小到大排序 第一轮先找到数组中最小的，是1 然后将1和数组中第一个位置上的数交换，这样，1就是最终的位置了 第二轮那么1排好了，我们从剩下的数里面找最小的数，是2 我们将2和第二个位置上的数交换位置 此时，1和2都已经固定好了位置 第三轮再从...","link":"","photos":[],"count_time":{"symbolsCount":"6.9k","symbolsTime":"6 mins."},"categories":[{"name":"Algorithm","slug":"Algorithm","count":3,"path":"api/categories/Algorithm.json"},{"name":"C++","slug":"C","count":3,"path":"api/categories/C.json"}],"tags":[{"name":"算法","slug":"算法","count":3,"path":"api/tags/算法.json"},{"name":"C++","slug":"C","count":3,"path":"api/tags/C.json"}],"author":{"name":"Aurora","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}