{"title":"选择排序","uid":"25abdf87b37439d6db828d8a717bff02","slug":"selection-sort","date":"2021-02-12T14:33:00.000Z","updated":"2023-10-18T01:53:17.945Z","comments":true,"path":"api/articles/selection-sort.json","keywords":"博客,后端,Java,算法,分布式,微服务,架构,业务开发,数据库,中间件,敏捷,管理,DDD,领域驱动设计,设计模式,搜索,消息队列","cover":[],"content":"<h2 id=\"排序过程\"><a href=\"#排序过程\" class=\"headerlink\" title=\"排序过程\"></a>排序过程</h2><p>假如对如下数组排序</p>\n<p><img src=\"https://gitee.com/jinxin.70/oss/raw/master/uPic/image-20210212212637607_2021_02_12_21_26_37.png\" alt=\"image-20210212212637607\"></p>\n<p>我们打算从小到大排序</p>\n<h3 id=\"第一轮\"><a href=\"#第一轮\" class=\"headerlink\" title=\"第一轮\"></a>第一轮</h3><p>先找到数组中最小的，是1</p>\n<p><img src=\"https://gitee.com/jinxin.70/oss/raw/master/uPic/image-20210212212805249_2021_02_12_21_28_05.png\" alt=\"image-20210212212805249\"></p>\n<p>然后将1和数组中第一个位置上的数交换，这样，1就是最终的位置了</p>\n<p><img src=\"https://gitee.com/jinxin.70/oss/raw/master/uPic/image-20210212212837283_2021_02_12_21_28_37.png\" alt=\"image-20210212212837283\"></p>\n<h3 id=\"第二轮\"><a href=\"#第二轮\" class=\"headerlink\" title=\"第二轮\"></a>第二轮</h3><p>那么1排好了，我们从剩下的数里面找最小的数，是2</p>\n<p><img src=\"https://gitee.com/jinxin.70/oss/raw/master/uPic/image-20210212212905854_2021_02_12_21_29_06.png\" alt=\"image-20210212212905854\"></p>\n<p>我们将2和第二个位置上的数交换位置</p>\n<p><img src=\"https://gitee.com/jinxin.70/oss/raw/master/uPic/image-20210212213045447_2021_02_12_21_30_45.png\" alt=\"image-20210212213045447\"></p>\n<p>此时，1和2都已经固定好了位置</p>\n<p><img src=\"https://gitee.com/jinxin.70/oss/raw/master/uPic/image-20210212213108930_2021_02_12_21_31_09.png\" alt=\"image-20210212213108930\"></p>\n<h3 id=\"第三轮\"><a href=\"#第三轮\" class=\"headerlink\" title=\"第三轮\"></a>第三轮</h3><p>再从第三个位置往后找最小的数，然后与第三个位置上的数交换位置</p>\n<p><img src=\"https://gitee.com/jinxin.70/oss/raw/master/uPic/image-20210212213214529_2021_02_12_21_32_14.png\" alt=\"image-20210212213214529\"></p>\n<p><img src=\"https://gitee.com/jinxin.70/oss/raw/master/uPic/image-20210212213226904_2021_02_12_21_32_27.png\" alt=\"image-20210212213226904\"></p>\n<p>依此类推，找到数组末尾就排好序了</p>\n<h3 id=\"第四轮\"><a href=\"#第四轮\" class=\"headerlink\" title=\"第四轮\"></a>第四轮</h3><p><img src=\"https://gitee.com/jinxin.70/oss/raw/master/uPic/image-20210212213300337_2021_02_12_21_33_00.png\" alt=\"image-20210212213300337\"></p>\n<p><img src=\"https://gitee.com/jinxin.70/oss/raw/master/uPic/image-20210212213317201_2021_02_12_21_33_17.png\" alt=\"image-20210212213317201\"></p>\n<h3 id=\"第五轮\"><a href=\"#第五轮\" class=\"headerlink\" title=\"第五轮\"></a>第五轮</h3><p><img src=\"https://gitee.com/jinxin.70/oss/raw/master/uPic/image-20210212213342282_2021_02_12_21_33_42.png\" alt=\"image-20210212213342282\"></p>\n<p><img src=\"https://gitee.com/jinxin.70/oss/raw/master/uPic/image-20210212213355567_2021_02_12_21_33_55.png\" alt=\"image-20210212213355567\"></p>\n<h3 id=\"第六轮\"><a href=\"#第六轮\" class=\"headerlink\" title=\"第六轮\"></a>第六轮</h3><p><img src=\"https://gitee.com/jinxin.70/oss/raw/master/uPic/image-20210212213442090_2021_02_12_21_34_42.png\" alt=\"image-20210212213442090\"></p>\n<p><img src=\"https://gitee.com/jinxin.70/oss/raw/master/uPic/image-20210212213453305_2021_02_12_21_34_53.png\" alt=\"image-20210212213453305\"></p>\n<h3 id=\"第七轮\"><a href=\"#第七轮\" class=\"headerlink\" title=\"第七轮\"></a>第七轮</h3><p><img src=\"https://gitee.com/jinxin.70/oss/raw/master/uPic/image-20210212213512606_2021_02_12_21_35_12.png\" alt=\"image-20210212213512606\"></p>\n<h3 id=\"第八轮\"><a href=\"#第八轮\" class=\"headerlink\" title=\"第八轮\"></a>第八轮</h3><p><img src=\"https://gitee.com/jinxin.70/oss/raw/master/uPic/image-20210212213535214_2021_02_12_21_35_35.png\" alt=\"image-20210212213535214\"></p>\n<h2 id=\"C-实现\"><a href=\"#C-实现\" class=\"headerlink\" title=\"C++实现\"></a>C++实现</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\n\nusing namespace std;\n&#x2F;**\n * 选择排序\n * @param arr\n * @param n\n *&#x2F;\nvoid selectionSort(int arr[], int n)&#123;\n    for (int i &#x3D; 0; i &lt; n; ++i) &#123;\n        &#x2F;&#x2F;寻找[1,n)区间里的最小值\n        int minIndex &#x3D; i;\n        for (int j &#x3D; i + 1; j &lt; n; ++j) &#123;\n            if(arr[j] &lt; arr[minIndex])&#123;\n                minIndex &#x3D; j;\n            &#125;\n        &#125;\n        swap(arr[i], arr[minIndex]);\n    &#125;\n&#125;\n\nint main()&#123;\n    int a[10] &#x3D; &#123;10,9,8,7,6,5,4,3,2,1&#125;;\n    selectionSort(a, 10);\n\n    for (int i &#x3D; 0; i &lt; 10; ++i) &#123;\n        cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;\n    &#125;\n    cout&lt;&lt;endl;\n    return 0;\n&#125;</code></pre>\n\n\n\n<h2 id=\"使用模板（范型）编写算法\"><a href=\"#使用模板（范型）编写算法\" class=\"headerlink\" title=\"使用模板（范型）编写算法\"></a>使用模板（范型）编写算法</h2><p>上面的实现，只能对int数组排序，我们需要对不同的类型排序，所以需要用到模板，有的语言叫范型。</p>\n<p><strong>Student.h</strong></p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">\n#ifndef ALGORITHMCPLUSPLUS_STUDENT_H\n#define ALGORITHMCPLUSPLUS_STUDENT_H\n\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nusing namespace std;\n\nstruct Student&#123;\n    string name;\n    int score;\n\n    &#x2F;&#x2F; 重载小于运算法,定义Student之间的比较方式\n    &#x2F;&#x2F; 如果分数相等，则按照名字的字母序排序\n    &#x2F;&#x2F; 如果分数不等，则分数高的靠前\n    bool operator&lt;(const Student&amp; otherStudent)&#123;\n        return score !&#x3D; otherStudent.score ?\n               score &gt; otherStudent.score : name &lt; otherStudent.name;\n    &#125;\n\n    &#x2F;&#x2F; 重载&lt;&lt;符号, 定义Student实例的打印输出方式\n    &#x2F;&#x2F; * 很多同学看到这里的C++语法, 头就大了, 甚至还有同学表示要重新学习C++语言\n    &#x2F;&#x2F; * 对于这个课程, 大可不必。C++语言并不是这个课程的重点,\n    &#x2F;&#x2F; * 大家也完全可以使用自己的方式书写代码, 最终只要能够打印出结果就好了, 比如设置一个成员函数, 叫做show()...\n    &#x2F;&#x2F; * 推荐大家阅读我在问答区向大家分享的一个学习心得: 【学习心得分享】请大家抓大放小，不要纠结于C++语言的语法细节\n    &#x2F;&#x2F; * 链接: http:&#x2F;&#x2F;coding.imooc.com&#x2F;learn&#x2F;questiondetail&#x2F;4100.html\n    friend ostream&amp; operator&lt;&lt;(ostream &amp;os, const Student &amp;student)&#123;\n\n        os&lt;&lt;&quot;Student: &quot;&lt;&lt;student.name&lt;&lt;&quot; &quot;&lt;&lt;student.score&lt;&lt;endl;\n        return os;\n    &#125;\n&#125;;\n\n#endif &#x2F;&#x2F;ALGORITHMCPLUSPLUS_STUDENT_H</code></pre>\n\n<p><strong>main.cpp</strong></p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\n\nusing namespace std;\n#include &quot;Student.h&quot;\ntemplate&lt;typename T&gt;\n&#x2F;**\n * 选择排序\n * @param arr\n * @param n\n *&#x2F;\nvoid selectionSort(T arr[], int n)&#123;\n    for (int i &#x3D; 0; i &lt; n; ++i) &#123;\n        &#x2F;&#x2F;寻找[1,n)区间里的最小值\n        int minIndex &#x3D; i;\n        for (int j &#x3D; i + 1; j &lt; n; ++j) &#123;\n            if(arr[j] &lt; arr[minIndex])&#123;\n                minIndex &#x3D; j;\n            &#125;\n        &#125;\n        swap(arr[i], arr[minIndex]);\n    &#125;\n&#125;\n\nint main()&#123;\n    int a[10] &#x3D; &#123;10,9,8,7,6,5,4,3,2,1&#125;;\n    selectionSort(a, 10);\n\n    for (int i &#x3D; 0; i &lt; 10; ++i) &#123;\n        cout&lt;&lt;a[i]&lt;&lt;&quot; &quot;;\n    &#125;\n    cout&lt;&lt;endl;\n\n    float b[4] &#x3D; &#123;4.4,3.3,2.2,1.1&#125;;\n    selectionSort(b, 4);\n    for (int i &#x3D; 0; i &lt; 4; ++i) &#123;\n        cout&lt;&lt;b[i]&lt;&lt; &quot; &quot;;\n    &#125;\n    cout&lt;&lt;endl;\n\n    string c[4] &#x3D; &#123;&quot;D&quot;,&quot;C&quot;,&quot;B&quot;,&quot;A&quot;&#125;;\n    selectionSort(c,4);\n    for( int i &#x3D; 0 ; i &lt; 4 ; i ++ )\n        cout&lt;&lt;c[i]&lt;&lt;&quot; &quot;;\n    cout&lt;&lt;endl;\n\n    Student d[4] &#x3D; &#123; &#123;&quot;D&quot;,90&#125; , &#123;&quot;C&quot;,100&#125; , &#123;&quot;B&quot;,95&#125; , &#123;&quot;A&quot;,95&#125; &#125;;\n    selectionSort(d,4);\n    for( int i &#x3D; 0 ; i &lt; 4 ; i ++ )\n        cout&lt;&lt;d[i];\n    cout&lt;&lt;endl;\n    return 0;\n&#125;</code></pre>\n\n<h2 id=\"随机生成算法测试用例（选学）\"><a href=\"#随机生成算法测试用例（选学）\" class=\"headerlink\" title=\"随机生成算法测试用例（选学）\"></a>随机生成算法测试用例（选学）</h2><p>思考🤔：</p>\n<p>我们上面代码的测试用例是硬编码的，我们希望生成自动生成。</p>\n<p><strong>SortTestHelper.h</strong></p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#ifndef ALGORITHMCPLUSPLUS_SORTTESTHELPER_H\n#define ALGORITHMCPLUSPLUS_SORTTESTHELPER_H\n#include &lt;iostream&gt;\n#include &lt;ctime&gt;\n#include &lt;cassert&gt;\n\nusing namespace std;\n\nnamespace SortTestHelper &#123;\n&#x2F;&#x2F; 生成有n个元素的随机数组,每个元素的随机范围为[rangeL, rangeR]\n    int *generateRandomArray(int n, int rangeL, int rangeR) &#123;\n\n        assert(rangeL &lt;&#x3D; rangeR);\n\n        int *arr &#x3D; new int[n];\n\n        srand(time(NULL));\n        for (int i &#x3D; 0; i &lt; n; i++)\n            arr[i] &#x3D; rand() % (rangeR - rangeL + 1) + rangeL;\n        return arr;\n    &#125;\n\n    &#x2F;&#x2F; 打印arr数组的所有内容\n    template&lt;typename T&gt;\n    void printArray(T arr[], int n) &#123;\n\n        for (int i &#x3D; 0; i &lt; n; i++)\n            cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;;\n        cout &lt;&lt; endl;\n\n        return;\n    &#125;\n  &#x2F;&#x2F; 判断arr数组是否有序\n    template&lt;typename T&gt;\n    bool isSorted(T arr[], int n) &#123;\n\n        for (int i &#x3D; 0; i &lt; n - 1; i++)\n            if (arr[i] &gt; arr[i + 1])\n                return false;\n\n        return true;\n    &#125;\n\n    &#x2F;&#x2F; 测试sort排序算法排序arr数组所得到结果的正确性和算法运行时间\n    &#x2F;&#x2F; * 使用VS编码的同学, 对于函数指针的写法和调用方法可能和课程中介绍的有所不同;\n    &#x2F;&#x2F; * 并且不同版本的VS, 其具体语法可能也有差异, 这是因为VS的编译器不完全是按照C++的标准实现的;\n    &#x2F;&#x2F; * 本课程按照C++11的标准进行书写。对于VS编译器带来的语法差异, 希望同学们可以自己在网上查找相关资料解决;\n    &#x2F;&#x2F; * 大家也可以在课程的官方QQ群中交流\n    &#x2F;&#x2F; * 另外, 使用函数指针本身并不是这个课程的重点, 大家也完全可以使用自己的方式书写代码, 最终只要能够测试出自己书写的算法的效率即可\n    &#x2F;&#x2F; * 推荐大家阅读我在问答区向大家分享的一个学习心得: 【学习心得分享】请大家抓大放小，不要纠结于C++语言的语法细节\n    &#x2F;&#x2F; * 链接: http:&#x2F;&#x2F;coding.imooc.com&#x2F;learn&#x2F;questiondetail&#x2F;4100.html\n    template&lt;typename T&gt;\n    void testSort(const string &amp;sortName, void (*sort)(T[], int), T arr[], int n) &#123;\n\n        clock_t startTime &#x3D; clock();\n        sort(arr, n);\n        clock_t endTime &#x3D; clock();\n\n        assert(isSorted(arr, n));\n        cout &lt;&lt; sortName &lt;&lt; &quot; : &quot; &lt;&lt; double(endTime - startTime) &#x2F; CLOCKS_PER_SEC &lt;&lt; &quot; s&quot; &lt;&lt; endl;\n&#x2F;&#x2F;CLOCKS_PER_SEC表示每秒运行的时间周期数\n        return;\n    &#125;\n&#125;;\n#endif &#x2F;&#x2F;ALGORITHMCPLUSPLUS_SORTTESTHELPER_H</code></pre>\n\n<p>testSort函数的入参void (*sort)(T[], int)是对一个函数的声明，其中</p>\n<ul>\n<li><p>void 是返回值，表示返回void</p>\n</li>\n<li><p>*sort是函数指针</p>\n</li>\n<li><p>(T[], int)表示参数，T数组和int类型变量表示长度</p>\n</li>\n</ul>\n<p>并且在函数声明上方要对T进行声明，template<typename T></p>\n<p><strong>main.cpp</strong></p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\n#include &quot;SortTestHelper.h&quot;\n\nusing namespace std;\n\ntemplate&lt;typename T&gt;\nvoid selectionSort(T arr[], int n)&#123;\n\n    for(int i &#x3D; 0 ; i &lt; n ; i ++)&#123;\n\n        int minIndex &#x3D; i;\n        for( int j &#x3D; i + 1 ; j &lt; n ; j ++ )\n            if( arr[j] &lt; arr[minIndex] )\n                minIndex &#x3D; j;\n\n        swap( arr[i] , arr[minIndex] );\n    &#125;\n&#125;\n\nint main() &#123;\n\n    &#x2F;&#x2F; 测试排序算法辅助函数\n    int N &#x3D; 20000;\n    int *arr &#x3D; SortTestHelper::generateRandomArray(N,0,100000);\n    selectionSort(arr,N);\n    SortTestHelper::printArray(arr,N);\n    delete[] arr;\n\n    return 0;\n&#125;</code></pre>\n","text":"排序过程假如对如下数组排序 我们打算从小到大排序 第一轮先找到数组中最小的，是1 然后将1和数组中第一个位置上的数交换，这样，1就是最终的位置了 第二轮那么1排好了，我们从剩下的数里面找最小的数，是2 我们将2和第二个位置上的数交换位置 此时，1和2都已经固定好了位置 第三轮再从...","link":"","photos":[],"count_time":{"symbolsCount":"6.9k","symbolsTime":"6 mins."},"categories":[{"name":"Algorithm","slug":"Algorithm","count":3,"path":"api/categories/Algorithm.json"},{"name":"C++","slug":"C","count":3,"path":"api/categories/C.json"}],"tags":[{"name":"算法","slug":"算法","count":3,"path":"api/tags/算法.json"},{"name":"C++","slug":"C","count":3,"path":"api/tags/C.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%8E%92%E5%BA%8F%E8%BF%87%E7%A8%8B\"><span class=\"toc-text\">排序过程</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%AC%AC%E4%B8%80%E8%BD%AE\"><span class=\"toc-text\">第一轮</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%AC%AC%E4%BA%8C%E8%BD%AE\"><span class=\"toc-text\">第二轮</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%AC%AC%E4%B8%89%E8%BD%AE\"><span class=\"toc-text\">第三轮</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%AC%AC%E5%9B%9B%E8%BD%AE\"><span class=\"toc-text\">第四轮</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%AC%AC%E4%BA%94%E8%BD%AE\"><span class=\"toc-text\">第五轮</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%AC%AC%E5%85%AD%E8%BD%AE\"><span class=\"toc-text\">第六轮</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%AC%AC%E4%B8%83%E8%BD%AE\"><span class=\"toc-text\">第七轮</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%AC%AC%E5%85%AB%E8%BD%AE\"><span class=\"toc-text\">第八轮</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#C-%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">C++实现</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8%E6%A8%A1%E6%9D%BF%EF%BC%88%E8%8C%83%E5%9E%8B%EF%BC%89%E7%BC%96%E5%86%99%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">使用模板（范型）编写算法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%9A%8F%E6%9C%BA%E7%94%9F%E6%88%90%E7%AE%97%E6%B3%95%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%EF%BC%88%E9%80%89%E5%AD%A6%EF%BC%89\"><span class=\"toc-text\">随机生成算法测试用例（选学）</span></a></li></ol>","author":{"name":"Aurora","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"动态代理","uid":"6b9ce45aac70d77e5b13dbe67f0c2d3a","slug":"动态代理","date":"2021-02-14T08:16:34.000Z","updated":"2023-10-18T01:53:17.945Z","comments":true,"path":"api/articles/动态代理.json","keywords":"博客,后端,Java,算法,分布式,微服务,架构,业务开发,数据库,中间件,敏捷,管理,DDD,领域驱动设计,设计模式,搜索,消息队列","cover":[],"text":"可以干什么 可以在运行时动态创建一个类，实现一个或多个接口，可以在不修改原有类的基础上动态为通过该类获取的对象添加方法、修改行为（增强） 动态代理是实现面向切面编程AOP的基础 AOP可以干什么？ 日志、性能监控、权限检查、数据库事务 AOP切面通过将切面逻辑和主体逻辑分离，使代...","link":"","photos":[],"count_time":{"symbolsCount":"3.7k","symbolsTime":"3 mins."},"categories":[{"name":"Java","slug":"Java","count":2,"path":"api/categories/Java.json"},{"name":"动态代理","slug":"动态代理","count":1,"path":"api/categories/动态代理.json"}],"tags":[{"name":"Java","slug":"Java","count":2,"path":"api/tags/Java.json"},{"name":"动态代理","slug":"动态代理","count":1,"path":"api/tags/动态代理.json"}],"author":{"name":"Aurora","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"类加载机制","uid":"7749a2b5879f92c33b3cacbb2a610b9b","slug":"类加载机制","date":"2021-02-09T12:58:16.000Z","updated":"2023-10-18T01:53:17.947Z","comments":true,"path":"api/articles/类加载机制.json","keywords":"博客,后端,Java,算法,分布式,微服务,架构,业务开发,数据库,中间件,敏捷,管理,DDD,领域驱动设计,设计模式,搜索,消息队列","cover":[],"text":"类加载器可以做什么热部署不重启Java程序的情况下，动态替换类的实现 比如JSP、OSGI 应用的模块化和隔离不同的类加载器可以加载相同的类，但互相隔离、互不影响 比如： Tomcat在一个程序中管理多个Web应用，每个Web应用有自己的classloader OSGI和Java...","link":"","photos":[],"count_time":{"symbolsCount":"6.5k","symbolsTime":"6 mins."},"categories":[{"name":"Java","slug":"Java","count":2,"path":"api/categories/Java.json"},{"name":"ClassLoader","slug":"ClassLoader","count":1,"path":"api/categories/ClassLoader.json"}],"tags":[{"name":"Java","slug":"Java","count":2,"path":"api/tags/Java.json"},{"name":"类加载器","slug":"类加载器","count":1,"path":"api/tags/类加载器.json"}],"author":{"name":"Aurora","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}