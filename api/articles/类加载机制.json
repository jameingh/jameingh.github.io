{"title":"类加载机制","uid":"7749a2b5879f92c33b3cacbb2a610b9b","slug":"类加载机制","date":"2021-02-09T12:58:16.000Z","updated":"2023-10-18T01:53:17.947Z","comments":true,"path":"api/articles/类加载机制.json","keywords":"博客,后端,Java,算法,分布式,微服务,架构,业务开发,数据库,中间件,敏捷,管理,DDD,领域驱动设计,设计模式,搜索,消息队列","cover":[],"content":"<h2 id=\"类加载器可以做什么\"><a href=\"#类加载器可以做什么\" class=\"headerlink\" title=\"类加载器可以做什么\"></a>类加载器可以做什么</h2><h3 id=\"热部署\"><a href=\"#热部署\" class=\"headerlink\" title=\"热部署\"></a>热部署</h3><p>不重启Java程序的情况下，动态替换类的实现</p>\n<p>比如JSP、OSGI</p>\n<h3 id=\"应用的模块化和隔离\"><a href=\"#应用的模块化和隔离\" class=\"headerlink\" title=\"应用的模块化和隔离\"></a>应用的模块化和隔离</h3><p>不同的类加载器可以加载相同的类，但互相隔离、互不影响</p>\n<p>比如：</p>\n<ul>\n<li>Tomcat在一个程序中管理多个Web应用，每个Web应用有自己的classloader</li>\n<li>OSGI和Java9实现动态模块化架构，每个模块有自己的ClassLoader</li>\n</ul>\n<h3 id=\"可以从不同的地方灵活加载类\"><a href=\"#可以从不同的地方灵活加载类\" class=\"headerlink\" title=\"可以从不同的地方灵活加载类\"></a>可以从不同的地方灵活加载类</h3><h2 id=\"为什么要学自定义classloader\"><a href=\"#为什么要学自定义classloader\" class=\"headerlink\" title=\"为什么要学自定义classloader\"></a>为什么要学自定义classloader</h2><ul>\n<li>有助于我们理解相关的系统和框架，比如Tomcat</li>\n<li>在业务需要的时候，可以自定义classloader实现动态灵活的功能</li>\n</ul>\n<h2 id=\"类加载的基本机制和过程\"><a href=\"#类加载的基本机制和过程\" class=\"headerlink\" title=\"类加载的基本机制和过程\"></a>类加载的基本机制和过程</h2><p>首先了解下，JDK提供的几个类加载器</p>\n<ul>\n<li>启动类加载器。加载基础类，主要是rt.jar</li>\n<li>扩展类加载器。加载ext目录下的jar</li>\n<li>应用程序类加载器。加载应用程序的类，包括自己写的和引入的第三方法类库</li>\n</ul>\n<p>要点：类加载器之间的关系，不是继承关系，是委派关系。</p>\n<h3 id=\"加载过程\"><a href=\"#加载过程\" class=\"headerlink\" title=\"加载过程\"></a>加载过程</h3><ol>\n<li>判断类是否加载过了，没有就一层层向上委派给父类，最后先让启动类加载器加载</li>\n<li>启动类加载到了，就返回Class对象，否则就让ext加载器加载</li>\n<li>ext加载器加载到了，就返回Class对象，否则就让应用类加载器加载</li>\n<li>应用类加载器加载到了，就返回Class对象，否则返回抛异常</li>\n</ol>\n<p>上面的加载过程就是双亲委派，一个类加载时，委派给ext类加载器，再委派给启动类加载器</p>\n<p>这样可以避免Java基础类库被覆盖</p>\n<p>JDK允许不遵循上面的加载过程，打破双亲委派规则：</p>\n<ul>\n<li>自定义的加载顺序<ul>\n<li>即使不遵守双亲委派，以java开头的类也不能被自定义类加载器加载，这是由Java的安全机制保证的，以避免混乱。</li>\n</ul>\n</li>\n<li>网状加载顺序<ul>\n<li>OSGI和Java9模块化系统，类加载器之间的关系是一个网，每个模块有一个类加载器</li>\n</ul>\n</li>\n<li>父加载器委派给子加载器加载<ul>\n<li>JNDI服务</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"理解ClassLoader\"><a href=\"#理解ClassLoader\" class=\"headerlink\" title=\"理解ClassLoader\"></a>理解ClassLoader</h2><p>ClassLoader类是一个抽象类。</p>\n<p>有两个子类</p>\n<ul>\n<li>AppClassLoader</li>\n<li>ExtClassLoader</li>\n</ul>\n<p>BootstrapClassLoader并不是它的子类，BootstrapClassLoader是C++写的，用于加载java基础类的。</p>\n<h3 id=\"Class对象的API\"><a href=\"#Class对象的API\" class=\"headerlink\" title=\"Class对象的API\"></a>Class对象的API</h3><h4 id=\"getClassLoader\"><a href=\"#getClassLoader\" class=\"headerlink\" title=\"getClassLoader\"></a>getClassLoader</h4><p>getClassLoader获取ClassLoader，来看看ClassLoader的API</p>\n<ul>\n<li>getParent<ul>\n<li>如果parent是Bootstrap ClassLoader，返回值为null</li>\n</ul>\n</li>\n<li>静态方法getSystemClassLoader<ul>\n<li>获取默认的系统类机载器</li>\n</ul>\n</li>\n<li>loadeClass方法<ul>\n<li><img src=\"https://gitee.com/jinxin.70/oss/raw/master/uPic2/VulpSW.png\" alt=\"示例\"></li>\n</ul>\n</li>\n<li>深入loadClass方法<ul>\n<li><img src=\"https://gitee.com/jinxin.70/oss/raw/master/uPic2/6HvGpS.png\"></li>\n</ul>\n</li>\n</ul>\n<h4 id=\"Class-forName\"><a href=\"#Class-forName\" class=\"headerlink\" title=\"Class.forName\"></a>Class.forName</h4><p><img src=\"https://gitee.com/jinxin.70/oss/raw/master/uPic2/jqjhdq.png\"></p>\n<ul>\n<li>第一个方法，使用系统类加载器加载</li>\n<li>第二个方法，指定ClassLoader，参数initialize表示加载后是否执行类的初始化代码（如static代码块），没有指定默认true。</li>\n</ul>\n<p>Class.forName和ClassLoader的loadClass方法都能加载类</p>\n<p>不同点：ClassLoader的loadClass方法不会执行类的初始化代码</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class CLInitDemo &#123;\n    public static class Hello &#123;\n        static &#123;\n            System.out.println(&quot;hello&quot;);\n        &#125;\n    &#125;;\n\n    public static void main(String[] args) &#123;\n        ClassLoader cl &#x3D; ClassLoader.getSystemClassLoader();\n        String className &#x3D; CLInitDemo.class.getName() + &quot;$Hello&quot;;\n        try &#123;\n            &#x2F;&#x2F;不会初始化类，不会执行静态方法和代码块\n\t\t\tClass&lt;?&gt; cls &#x3D; cl.loadClass(className);\n\t\t\t&#x2F;&#x2F;会初始化类，会执行静态方法和静态代码块\n&#x2F;&#x2F;            Class&lt;?&gt; cls &#x3D; Class.forName(className);\n        &#125; catch (ClassNotFoundException e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<h2 id=\"类加载器的应用：可配置的策略\"><a href=\"#类加载器的应用：可配置的策略\" class=\"headerlink\" title=\"类加载器的应用：可配置的策略\"></a>类加载器的应用：可配置的策略</h2><p>策略模式，将不同策略实现类，配置在外部文件中，不同场合使用不同的配置，通过反射、类加载器加载配置中的类。不需要改代码就可以改变程序的行为</p>\n<p><a href=\"https://gitee.com/jinxin.70/alpha1/commit/5fa782b61f350874eaa919c397fa21630911fb40\">代码地址</a></p>\n<h2 id=\"自定义ClassLoader\"><a href=\"#自定义ClassLoader\" class=\"headerlink\" title=\"自定义ClassLoader\"></a>自定义ClassLoader</h2><h3 id=\"一般步骤\"><a href=\"#一般步骤\" class=\"headerlink\" title=\"一般步骤\"></a>一般步骤</h3><ol>\n<li>继承ClassLoader</li>\n<li>重写findClass<ol>\n<li>从class文件位置加载类</li>\n<li>转成字节数组</li>\n<li>调用defineClass方法</li>\n</ol>\n</li>\n</ol>\n<h3 id=\"案例\"><a href=\"#案例\" class=\"headerlink\" title=\"案例\"></a>案例</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class MyClassLoader extends ClassLoader&#123;\n    private static final String BASE_DIR &#x3D; &quot;data&#x2F;classloader&#x2F;&quot;;\n\n    @Override\n    protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;\n        String fileName &#x3D; name.replaceAll(&quot;\\\\.&quot;, &quot;&#x2F;&quot;);\n        fileName &#x3D; BASE_DIR + fileName + &quot;.class&quot;;\n        try &#123;\n            byte[] bytes &#x3D; BinaryFileUtils.readFileToByteArray(fileName);\n            return defineClass(name, bytes, 0, bytes.length);\n        &#125; catch (IOException ex) &#123;\n            throw new ClassNotFoundException(&quot;failed to load class &quot; + name, ex);\n        &#125;\n    &#125;\n&#125;</code></pre>\n\n<h3 id=\"自定义了类加载器之后呢？能干嘛？\"><a href=\"#自定义了类加载器之后呢？能干嘛？\" class=\"headerlink\" title=\"自定义了类加载器之后呢？能干嘛？\"></a>自定义了类加载器之后呢？能干嘛？</h3><ul>\n<li>可以创建多个MyClassLoader，对同一个类，每个MyClassLoader都可以加载一次，得到同一个类对不同Class对象</li>\n<li>可以实现隔离<ul>\n<li>不同模块使用不同的类加载器</li>\n</ul>\n</li>\n<li>可以实现热部署<ul>\n<li>使用自定义类加载器，加载Class，得到的就是新的，从而可以实现动态更新</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"热部署实验\"><a href=\"#热部署实验\" class=\"headerlink\" title=\"热部署实验\"></a>热部署实验</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class HotDeployDemo &#123;\n    &#x2F;**\n     * 实现类名称\n     *&#x2F;\n    private static final String CLASS_NAME &#x3D; &quot;com.kim.base.classloader.custom.HelloImpl&quot;;\n    &#x2F;**\n     * class文件路径\n     *&#x2F;\n    private static final String FILE_NAME &#x3D; &quot;target&#x2F;classes&#x2F;&quot;\n            +CLASS_NAME.replaceAll(&quot;\\\\.&quot;, &quot;&#x2F;&quot;)+&quot;.class&quot;;\n    &#x2F;**\n     * IHelloService实现类\n     *&#x2F;\n    private static volatile IHelloService helloService;\n\n    public static IHelloService getHelloService() &#123;\n        if (helloService !&#x3D; null) &#123;\n            return helloService;\n        &#125;\n        synchronized (HotDeployDemo.class) &#123;\n            if (helloService &#x3D;&#x3D; null) &#123;\n                helloService &#x3D; createHelloService();\n            &#125;\n            return helloService;\n        &#125;\n    &#125;\n\n    &#x2F;**\n     * 通过自定义类加载器，从指定的目录加载IHelloService实现类\n     * @return\n     *&#x2F;\n    private static IHelloService createHelloService() &#123;\n        try &#123;\n            MyClassLoader cl &#x3D; new MyClassLoader();\n            Class&lt;?&gt; cls &#x3D; cl.loadClass(CLASS_NAME);\n            if (cls !&#x3D; null) &#123;\n                return (IHelloService) cls.newInstance();\n            &#125;\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125;\n        return null;\n    &#125;\n\n    public static void client() &#123;\n        Thread t &#x3D; new Thread() &#123;\n            @Override\n            public void run() &#123;\n                try &#123;\n                    while (true) &#123;\n                        IHelloService helloService &#x3D; getHelloService();\n                        helloService.sayHello();\n                        Thread.sleep(1000);\n                    &#125;\n                &#125; catch (InterruptedException e) &#123;\n                &#125;\n            &#125;\n        &#125;;\n        t.start();\n    &#125;\n\n    &#x2F;**\n     * 一个监视文件变化的线程，文件如果变化了，就重新加载\n     *&#x2F;\n    public static void monitor() &#123;\n        Thread t &#x3D; new Thread() &#123;\n            private long lastModified &#x3D; new File(FILE_NAME).lastModified();\n\n            @Override\n            public void run() &#123;\n                try &#123;\n                    while (true) &#123;\n                        Thread.sleep(100);\n                        long now &#x3D; new File(FILE_NAME).lastModified();\n                        if (now !&#x3D; lastModified) &#123;\n                            lastModified &#x3D; now;\n                            reloadHelloService();\n                        &#125;\n                    &#125;\n                &#125; catch (InterruptedException e) &#123;\n                &#125;\n            &#125;\n        &#125;;\n        t.start();\n    &#125;\n\n    public static void reloadHelloService() &#123;\n        System.out.println(&quot;文件被修改了，重新加载&quot;);\n        helloService &#x3D; createHelloService();\n    &#125;\n\n    public static void main(String[] args) &#123;\n        monitor();\n        client();\n    &#125;\n&#125;</code></pre>\n\n<ul>\n<li>我们把创建HelloService的实现的方式提取出来，通过自定义类加载器，在指定目录加载他的实现</li>\n<li>我们使用一个线程，监听自定义类加载器加载类的地方，监听具体文件的变化，有变化就重新实例化一个自定义类加载器，加载新的类，使其生效</li>\n<li>模拟客户端调用<ul>\n<li>用一个线程，无限循环去调用helloServicve的方法sayHello</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>通过类加载器的学习，我们知道了类加载器最起码可以做如下三样事情：</p>\n<ol>\n<li>热部署</li>\n<li>应用的模块化和隔离</li>\n<li>从不同的地方灵活加载</li>\n</ol>\n<p>我们使用的tomcat就是使用类加载器的典型例子，通过案例和实验代码的运行、调试、理解，对类加载器的应用应该会有更深的理解，对tomcat的运行机制也不会觉得那么神秘。</p>\n<p>读者自己可以试试实现一个简单的tomcat，可以实现热部署、应用的隔离。</p>\n","text":"类加载器可以做什么热部署不重启Java程序的情况下，动态替换类的实现 比如JSP、OSGI 应用的模块化和隔离不同的类加载器可以加载相同的类，但互相隔离、互不影响 比如： Tomcat在一个程序中管理多个Web应用，每个Web应用有自己的classloader OSGI和Java...","link":"","photos":[],"count_time":{"symbolsCount":"6.5k","symbolsTime":"6 mins."},"categories":[{"name":"Java","slug":"Java","count":2,"path":"api/categories/Java.json"},{"name":"ClassLoader","slug":"ClassLoader","count":1,"path":"api/categories/ClassLoader.json"}],"tags":[{"name":"Java","slug":"Java","count":2,"path":"api/tags/Java.json"},{"name":"类加载器","slug":"类加载器","count":1,"path":"api/tags/类加载器.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%8F%AF%E4%BB%A5%E5%81%9A%E4%BB%80%E4%B9%88\"><span class=\"toc-text\">类加载器可以做什么</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%83%AD%E9%83%A8%E7%BD%B2\"><span class=\"toc-text\">热部署</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BA%94%E7%94%A8%E7%9A%84%E6%A8%A1%E5%9D%97%E5%8C%96%E5%92%8C%E9%9A%94%E7%A6%BB\"><span class=\"toc-text\">应用的模块化和隔离</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%AF%E4%BB%A5%E4%BB%8E%E4%B8%8D%E5%90%8C%E7%9A%84%E5%9C%B0%E6%96%B9%E7%81%B5%E6%B4%BB%E5%8A%A0%E8%BD%BD%E7%B1%BB\"><span class=\"toc-text\">可以从不同的地方灵活加载类</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%AD%A6%E8%87%AA%E5%AE%9A%E4%B9%89classloader\"><span class=\"toc-text\">为什么要学自定义classloader</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%9C%BA%E5%88%B6%E5%92%8C%E8%BF%87%E7%A8%8B\"><span class=\"toc-text\">类加载的基本机制和过程</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B\"><span class=\"toc-text\">加载过程</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%90%86%E8%A7%A3ClassLoader\"><span class=\"toc-text\">理解ClassLoader</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Class%E5%AF%B9%E8%B1%A1%E7%9A%84API\"><span class=\"toc-text\">Class对象的API</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#getClassLoader\"><span class=\"toc-text\">getClassLoader</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Class-forName\"><span class=\"toc-text\">Class.forName</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%9A%E5%8F%AF%E9%85%8D%E7%BD%AE%E7%9A%84%E7%AD%96%E7%95%A5\"><span class=\"toc-text\">类加载器的应用：可配置的策略</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%87%AA%E5%AE%9A%E4%B9%89ClassLoader\"><span class=\"toc-text\">自定义ClassLoader</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%80%E8%88%AC%E6%AD%A5%E9%AA%A4\"><span class=\"toc-text\">一般步骤</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%A1%88%E4%BE%8B\"><span class=\"toc-text\">案例</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%86%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E4%B9%8B%E5%90%8E%E5%91%A2%EF%BC%9F%E8%83%BD%E5%B9%B2%E5%98%9B%EF%BC%9F\"><span class=\"toc-text\">自定义了类加载器之后呢？能干嘛？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%83%AD%E9%83%A8%E7%BD%B2%E5%AE%9E%E9%AA%8C\"><span class=\"toc-text\">热部署实验</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a></li></ol>","author":{"name":"Aurora","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"选择排序","uid":"25abdf87b37439d6db828d8a717bff02","slug":"selection-sort","date":"2021-02-12T14:33:00.000Z","updated":"2023-10-18T01:53:17.945Z","comments":true,"path":"api/articles/selection-sort.json","keywords":"博客,后端,Java,算法,分布式,微服务,架构,业务开发,数据库,中间件,敏捷,管理,DDD,领域驱动设计,设计模式,搜索,消息队列","cover":[],"text":"排序过程假如对如下数组排序 我们打算从小到大排序 第一轮先找到数组中最小的，是1 然后将1和数组中第一个位置上的数交换，这样，1就是最终的位置了 第二轮那么1排好了，我们从剩下的数里面找最小的数，是2 我们将2和第二个位置上的数交换位置 此时，1和2都已经固定好了位置 第三轮再从...","link":"","photos":[],"count_time":{"symbolsCount":"6.9k","symbolsTime":"6 mins."},"categories":[{"name":"Algorithm","slug":"Algorithm","count":3,"path":"api/categories/Algorithm.json"},{"name":"C++","slug":"C","count":3,"path":"api/categories/C.json"}],"tags":[{"name":"算法","slug":"算法","count":3,"path":"api/tags/算法.json"},{"name":"C++","slug":"C","count":3,"path":"api/tags/C.json"}],"author":{"name":"Aurora","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{}}