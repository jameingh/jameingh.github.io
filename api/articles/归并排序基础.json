{"title":"归并排序基础","uid":"31a861b85a2c5696a7a9b4dfe9060a08","slug":"归并排序基础","date":"2021-03-22T14:18:33.000Z","updated":"2021-12-04T13:07:53.310Z","comments":true,"path":"api/articles/归并排序基础.json","keywords":"博客,后端,Java,算法,分布式,微服务,架构,业务开发,数据库,中间件,敏捷,管理,DDD,领域驱动设计,设计模式,搜索,消息队列","cover":[],"content":"<h2 id=\"前要回顾\"><a href=\"#前要回顾\" class=\"headerlink\" title=\"前要回顾\"></a>前要回顾</h2><p>前面我们学习了选择排序和插入排序，比较好理解，但是复杂度是O(n^2)</p>\n<p>不是说O(n^2)不好，在数据量不大的时候，其实是可以用的，因为实现简单。</p>\n<p>有没有更好的排序方案呢？</p>\n<p>下面看看时间复杂度是O(nlogn)的排序算法，归并排序。</p>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>假如要对下面的数组排序</p>\n<p><img src=\"https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20210322195817245.png\" alt=\"image-20210322195817245\"></p>\n<p>归并排序的思路是：把数组对半分，想办法把左边的数组排序，把右半部分排序，最后合并。</p>\n<p>在排序左半部分时，再把左半部分在对半分，并排序，合并。</p>\n<p><img src=\"https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20210322200027636.png\" alt=\"image-20210322200027636\"></p>\n<p>这样对半分，分到最后，每一部分只有一个元素，就不能再分了，然后顺序也排好了，只需要每部分依此归并。</p>\n<h2 id=\"时间复杂度分析\"><a href=\"#时间复杂度分析\" class=\"headerlink\" title=\"时间复杂度分析\"></a>时间复杂度分析</h2><p>我们看下分成了几层，</p>\n<p><img src=\"https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20210322200310337.png\" alt=\"image-20210322200310337\"></p>\n<p>总共有log(n)层。分析：每次对半分，分多少次？log以2为底，8的对数，是4。</p>\n<p>再以O(n)的算法归并，所以总体复杂度是O(nlogn)。</p>\n<h2 id=\"实现技巧\"><a href=\"#实现技巧\" class=\"headerlink\" title=\"实现技巧\"></a>实现技巧</h2><p>使用递归思想。</p>\n<p>需要开辟临时空间，辅助归并。</p>\n<p>使用三个索引对归并过程跟踪。</p>\n<p><img src=\"https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20210322203412929.png\" alt=\"image-20210322203412929\"></p>\n<p>蓝色的箭头，表示最终在归并的过程中我们需要跟踪的位置。</p>\n<p>两个红色的箭头指向两个排好序的数组当前我们要考虑的元素。</p>\n<h2 id=\"归并排序过程\"><a href=\"#归并排序过程\" class=\"headerlink\" title=\"归并排序过程\"></a>归并排序过程</h2><p>我们考虑2，1谁应该先放到最终数组中</p>\n<p><img src=\"https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20210322203551791.png\" alt=\"image-20210322203551791\"></p>\n<p>1比2小，将1放入最终数组中，蓝色箭头移动到下一个位置</p>\n<p><img src=\"https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20210322203626303.png\" alt=\"image-20210322203626303\"></p>\n<p>与此同时，1原先所在数据的红色指针，考虑移动到下一个位置</p>\n<p><img src=\"https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20210322203707909.png\" alt=\"image-20210322203707909\"></p>\n<p>此时1已经在原数组中排好序了，</p>\n<p>在考虑2和4，2更小</p>\n<p><img src=\"https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20210322203816621.png\" alt=\"image-20210322203816621\"></p>\n<p>2放入原数组第二个位置，同时原数组的蓝色指针向后移一位，</p>\n<p><img src=\"https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20210322203849566.png\" alt=\"image-20210322203849566\"></p>\n<p>与此同时，2原来所在数组的红色指针，向后移到一个位置</p>\n<p><img src=\"https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20210322203918467.png\" alt=\"image-20210322203918467\"></p>\n<p>再考虑3和4，</p>\n<p><img src=\"https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20210322203947587.png\" alt=\"image-20210322203947587\"></p>\n<p>3比4小，3放入原数组的蓝色指针指向的位置，原数组蓝色指针向后移动一位</p>\n<p><img src=\"https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20210322204007067.png\" alt=\"image-20210322204007067\"></p>\n<p>与此同时，3所在原数组的红色指针，向后移动一位。</p>\n<p><img src=\"https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20210322204118074.png\" alt=\"image-20210322204118074\"></p>\n<p>此时比较6和4，4比6小，4放到原数组的蓝色指针指向的位置，原数组蓝色指针向后移动一位，同时4所在原数组的红色指针向后移动一位。</p>\n<p><img src=\"https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20210322204234033.png\" alt=\"image-20210322204234033\"></p>\n<p><img src=\"https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20210322204249810.png\" alt=\"image-20210322204249810\"></p>\n<p>指针就绪后，再考虑6和5比较，依此类推。</p>\n<h2 id=\"难点\"><a href=\"#难点\" class=\"headerlink\" title=\"难点\"></a>难点</h2><p>使用了三个索引（指针），必须定义清楚。</p>\n<p><img src=\"https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20210322204429805.png\" alt=\"image-20210322204429805\"></p>\n<p>定义i和j，为当前正在考虑的元素，k用来指向i和j比较后，最终应该放到归并数组中的位置。</p>\n<p>注意，k表示的是下一个需要放置的位置，不是归并后的最后位置。</p>\n<p>维持三个变量在实现过程中，始终符合我们的定义，是正确实现的基础。</p>\n<p>为了防止越界，需要定义另外两个变量l(left)和r(right)，分别表示最左边和最右边的位置。</p>\n<p><img src=\"https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20210322204901158.png\" alt=\"image-20210322204901158\"></p>\n<p>还需要一个表示已经排好序的中间数组的最后一个位置m（middle）。</p>\n<p><img src=\"https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20210322205000663.png\" alt=\"image-20210322205000663\"></p>\n<h2 id=\"C-实现\"><a href=\"#C-实现\" class=\"headerlink\" title=\"C++实现\"></a>C++实现</h2><p>main.cpp</p>\n<pre class=\"line-numbers language-C++\" data-language=\"C++\"><code class=\"language-C++\">#include &lt;iostream&gt;\n#include &quot;SortTestHelper.h&quot;\n#include &quot;InsertionSort.h&quot;\n\nusing namespace std;\n\n\n&#x2F;&#x2F; 将arr[l...mid]和arr[mid+1...r]两部分进行归并\ntemplate&lt;typename  T&gt;\nvoid __merge(T arr[], int l, int mid, int r)&#123;\n\n    &#x2F;&#x2F;* VS不支持动态长度数组, 即不能使用 T aux[r-l+1]的方式申请aux的空间\n    &#x2F;&#x2F;* 使用VS的同学, 请使用new的方式申请aux空间\n    &#x2F;&#x2F;* 使用new申请空间, 不要忘了在__merge函数的最后, delete掉申请的空间:)\n\n    &#x2F;&#x2F;辅助空间对大小，由于是前闭后闭区间，所以是r-l+1\n    T aux[r-l+1];\n    &#x2F;&#x2F;T *aux &#x3D; new T[r-l+1];\n\n    &#x2F;&#x2F;临时空间初始化\n    for( int i &#x3D; l ; i &lt;&#x3D; r; i ++ )\n        &#x2F;&#x2F;aux是从零开始的，但是处理的arr空间是动态的l开始的，两个数组有一个l的距离偏移\n        aux[i-l] &#x3D; arr[i];\n\n    &#x2F;&#x2F; 初始化，i指向左半部分的起始索引位置l；j指向右半部分起始索引位置mid+1\n    int i &#x3D; l, j &#x3D; mid+1;\n    &#x2F;&#x2F;从l遍历到r，左边遍历到右边，决定k的位置\n    for( int k &#x3D; l ; k &lt;&#x3D; r; k ++ )&#123;\n\n        if( i &gt; mid )&#123;  &#x2F;&#x2F; 如果左半部分元素已经全部处理完毕\n            arr[k] &#x3D; aux[j-l]; j ++;\n        &#125;\n        else if( j &gt; r )&#123;  &#x2F;&#x2F; 如果右半部分元素已经全部处理完毕\n            arr[k] &#x3D; aux[i-l]; i ++;\n        &#125;\n        else if( aux[i-l] &lt; aux[j-l] ) &#123;  &#x2F;&#x2F; 左半部分所指元素 &lt; 右半部分所指元素\n            arr[k] &#x3D; aux[i-l]; i ++;\n        &#125;\n        else&#123;  &#x2F;&#x2F; 左半部分所指元素 &gt;&#x3D; 右半部分所指元素\n            arr[k] &#x3D; aux[j-l]; j ++;\n        &#125;\n    &#125;\n\n    &#x2F;&#x2F;delete[] aux;\n&#125;\n\n&#x2F;&#x2F; 递归使用归并排序,对arr[l...r]的范围进行排序\ntemplate&lt;typename T&gt;\nvoid __mergeSort(T arr[], int l, int r)&#123;\n\n    &#x2F;&#x2F;处理递归到底的情况，l&gt;&#x3D;r表示要处理的是至多一个元素的情况\n    if( l &gt;&#x3D; r )\n        return;\n\n    &#x2F;&#x2F;计算中点位置 思考：当l和r很大时，l+r可能会溢出，如何避免\n    int mid &#x3D; (l+r)&#x2F;2;\n    &#x2F;&#x2F;对一半进行归并排序\n    __mergeSort(arr, l, mid);\n    &#x2F;&#x2F;对另一半进行归并排序\n    __mergeSort(arr, mid+1, r);\n    &#x2F;&#x2F;合并上面对两半数据\n    __merge(arr, l, mid, r);\n&#125;\n\ntemplate&lt;typename T&gt;\nvoid mergeSort(T arr[], int n)&#123;\n\n    __mergeSort( arr , 0 , n-1 );\n&#125;\n\n\n&#x2F;&#x2F; 比较InsertionSort和MergeSort两种排序算法的性能效率\n&#x2F;&#x2F; 整体而言, MergeSort的性能最优, 对于近乎有序的数组的特殊情况, 见测试2的详细注释\nint main() &#123;\n\n    &#x2F;&#x2F; Merge Sort是我们学习的第一个O(nlogn)复杂度的算法\n    &#x2F;&#x2F; 可以在1秒之内轻松处理100万数量级的数据\n    &#x2F;&#x2F; 注意：不要轻易尝试使用SelectionSort, InsertionSort或者BubbleSort处理100万级的数据\n    &#x2F;&#x2F; 否则，你就见识了O(n^2)的算法和O(nlogn)算法的本质差异：）\n    int n &#x3D; 50000;\n\n    &#x2F;&#x2F; 测试1 一般性测试\n    cout&lt;&lt;&quot;Test for random array, size &#x3D; &quot;&lt;&lt;n&lt;&lt;&quot;, random range [0, &quot;&lt;&lt;n&lt;&lt;&quot;]&quot;&lt;&lt;endl;\n    int* arr1 &#x3D; SortTestHelper::generateRandomArray(n,0,n);\n    int* arr2 &#x3D; SortTestHelper::copyIntArray(arr1, n);\n\n    SortTestHelper::testSort(&quot;Insertion Sort&quot;, insertionSort, arr1, n);\n    SortTestHelper::testSort(&quot;Merge Sort&quot;,     mergeSort,     arr2, n);\n\n    delete[] arr1;\n    delete[] arr2;\n\n    cout&lt;&lt;endl;\n\n\n    &#x2F;&#x2F; 测试2 测试近乎有序的数组\n    &#x2F;&#x2F; 对于近乎有序的数组, 数组越有序, InsertionSort的时间性能越趋近于O(n)\n    &#x2F;&#x2F; 所以可以尝试, 当swapTimes比较大时, MergeSort更快\n    &#x2F;&#x2F; 但是当swapTimes小到一定程度, InsertionSort变得比MergeSort快\n    int swapTimes &#x3D; 10;\n    assert( swapTimes &gt;&#x3D; 0 );\n\n    cout&lt;&lt;&quot;Test for nearly ordered array, size &#x3D; &quot;&lt;&lt;n&lt;&lt;&quot;, swap time &#x3D; &quot;&lt;&lt;swapTimes&lt;&lt;endl;\n    arr1 &#x3D; SortTestHelper::generateNearlyOrderedArray(n,swapTimes);\n    arr2 &#x3D; SortTestHelper::copyIntArray(arr1, n);\n\n    SortTestHelper::testSort(&quot;Insertion Sort&quot;, insertionSort, arr1, n);\n    SortTestHelper::testSort(&quot;Merge Sort&quot;,     mergeSort,     arr2, n);\n\n    delete[] arr1;\n    delete[] arr2;\n\n    return 0;\n&#125;</code></pre>\n\n<p><a href=\"https://gitee.com/jinxin.70/alpha1/commit/a282842861ad89dea328e02449972c09ab5fd7fd\">完整代码地址</a></p>\n<h2 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h2><h3 id=\"优化点一\"><a href=\"#优化点一\" class=\"headerlink\" title=\"优化点一\"></a>优化点一</h3><p>在数据基本有序的情况下，归并排序比插入排序性能还是差的。</p>\n<p>代码可以进一步优化，只有在<code>arr[mid]&gt;arr[mid+1]</code>时，才归并，否则已经从小到大排好了，就不必归并，从而在基本有序的时候减少排序操作。</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;对一半进行归并排序\n    __mergeSort(arr, l, mid);\n    &#x2F;&#x2F;对另一半进行归并排序\n    __mergeSort(arr, mid+1, r);\n    if(arr[mid]&gt;arr[mid+1]) &#123;\n        &#x2F;&#x2F;合并上面对两半数据\n        __merge(arr, l, mid, r);\n    &#125;</code></pre>\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>这里总结一下设计排序算法时，需要考虑的设计点：</p>\n<ul>\n<li>考虑是否要对近乎有序的数据进行排序</li>\n</ul></blockquote>\n<h3 id=\"优化点二\"><a href=\"#优化点二\" class=\"headerlink\" title=\"优化点二\"></a>优化点二</h3><p>在数据量小的时候，数组近乎有序的概率大，插入排序有优势；</p>\n<p>在数据量小的时候，插入排序是比归并排序快的。</p>\n<p>所以，可以进一步优化。</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F; 优化2: 对于小规模数组, 使用插入排序\n    if( r - l &lt;&#x3D; 15 )&#123;\n        insertionSort(arr, l, r);\n        return;\n    &#125;</code></pre>\n\n<p><a href=\"https://gitee.com/jinxin.70/alpha1/commit/7ee0c69fe9e8b52c39ca918257ea33677ab6e650\">完整代码地址</a></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>本小结介绍了归并排序算法</p>\n<ul>\n<li>归并排序是一种拆分合并的思路</li>\n<li>使用递归的技巧实现</li>\n<li>需要注意算法的实现过程中，使用到一些辅助的指针和临时空间</li>\n<li>归并排序的效率是O(nlogn)，但是在数据量不大时，插入排序效率更高</li>\n<li>在数组近乎有序的时候，可以做一点优化，减少归并次数</li>\n</ul>\n","feature":true,"text":"前要回顾前面我们学习了选择排序和插入排序，比较好理解，但是复杂度是O(n^2) 不是说O(n^2)不好，在数据量不大的时候，其实是可以用的，因为实现简单。 有没有更好的排序方案呢？ 下面看看时间复杂度是O(nlogn)的排序算法，归并排序。 思路假如要对下面的数组排序 归并排序的...","link":"","photos":[],"count_time":{"symbolsCount":"5.5k","symbolsTime":"5 mins."},"categories":[{"name":"Algorithm","slug":"Algorithm","count":3,"path":"api/categories/Algorithm.json"},{"name":"C++","slug":"C","count":3,"path":"api/categories/C.json"}],"tags":[{"name":"算法","slug":"算法","count":3,"path":"api/tags/算法.json"},{"name":"C++","slug":"C","count":3,"path":"api/tags/C.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%89%8D%E8%A6%81%E5%9B%9E%E9%A1%BE\"><span class=\"toc-text\">前要回顾</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%9D%E8%B7%AF\"><span class=\"toc-text\">思路</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90\"><span class=\"toc-text\">时间复杂度分析</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E7%8E%B0%E6%8A%80%E5%B7%A7\"><span class=\"toc-text\">实现技巧</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E8%BF%87%E7%A8%8B\"><span class=\"toc-text\">归并排序过程</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%9A%BE%E7%82%B9\"><span class=\"toc-text\">难点</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#C-%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">C++实现</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BC%98%E5%8C%96\"><span class=\"toc-text\">优化</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BC%98%E5%8C%96%E7%82%B9%E4%B8%80\"><span class=\"toc-text\">优化点一</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BC%98%E5%8C%96%E7%82%B9%E4%BA%8C\"><span class=\"toc-text\">优化点二</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a></li></ol>","author":{"name":"Aurora","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{},"next_post":{"title":"插入排序","uid":"f2ea62009b2a302d5e2076e5efd27611","slug":"插入排序","date":"2021-03-16T11:28:01.000Z","updated":"2021-12-04T13:07:53.310Z","comments":true,"path":"api/articles/插入排序.json","keywords":"博客,后端,Java,算法,分布式,微服务,架构,业务开发,数据库,中间件,敏捷,管理,DDD,领域驱动设计,设计模式,搜索,消息队列","cover":[],"text":"前要回顾前面我们提供了一个对数据排序的方案，是选择排序。 排序的过程，回顾一下。 如果要对数组进行从小到大排序，选择排序怎么做呢？ 我们对数组的每个位置进行遍历，举个例子： 比如一开始，第一个位置，我们要放置最小的元素到这个位置，于是从所有元素中选择一个最小的。然后和第一个位置的...","link":"","photos":[],"count_time":{"symbolsCount":"2.7k","symbolsTime":"2 mins."},"categories":[{"name":"Algorithm","slug":"Algorithm","count":3,"path":"api/categories/Algorithm.json"},{"name":"C++","slug":"C","count":3,"path":"api/categories/C.json"}],"tags":[{"name":"算法","slug":"算法","count":3,"path":"api/tags/算法.json"},{"name":"C++","slug":"C","count":3,"path":"api/tags/C.json"}],"author":{"name":"Aurora","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true}}