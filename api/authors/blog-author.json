{"name":"Aurora","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}},"post_list":[{"title":"归并排序基础","uid":"31a861b85a2c5696a7a9b4dfe9060a08","slug":"归并排序基础","date":"2021-03-22T14:18:33.000Z","updated":"2023-10-18T01:53:17.946Z","comments":true,"path":"api/articles/归并排序基础.json","keywords":"博客,后端,Java,算法,分布式,微服务,架构,业务开发,数据库,中间件,敏捷,管理,DDD,领域驱动设计,设计模式,搜索,消息队列","cover":[],"text":"前要回顾前面我们学习了选择排序和插入排序，比较好理解，但是复杂度是O(n^2) 不是说O(n^2)不好，在数据量不大的时候，其实是可以用的，因为实现简单。 有没有更好的排序方案呢？ 下面看看时间复杂度是O(nlogn)的排序算法，归并排序。 思路假如要对下面的数组排序 归并排序的...","link":"","photos":[],"count_time":{"symbolsCount":"5.5k","symbolsTime":"5 mins."},"categories":[{"name":"Algorithm","slug":"Algorithm","count":3,"path":"api/categories/Algorithm.json"},{"name":"C++","slug":"C","count":3,"path":"api/categories/C.json"}],"tags":[{"name":"算法","slug":"算法","count":3,"path":"api/tags/算法.json"},{"name":"C++","slug":"C","count":3,"path":"api/tags/C.json"}],"author":{"name":"Aurora","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},{"title":"插入排序","uid":"f2ea62009b2a302d5e2076e5efd27611","slug":"插入排序","date":"2021-03-16T11:28:01.000Z","updated":"2023-10-18T01:53:17.946Z","comments":true,"path":"api/articles/插入排序.json","keywords":"博客,后端,Java,算法,分布式,微服务,架构,业务开发,数据库,中间件,敏捷,管理,DDD,领域驱动设计,设计模式,搜索,消息队列","cover":[],"text":"前要回顾前面我们提供了一个对数据排序的方案，是选择排序。 排序的过程，回顾一下。 如果要对数组进行从小到大排序，选择排序怎么做呢？ 我们对数组的每个位置进行遍历，举个例子： 比如一开始，第一个位置，我们要放置最小的元素到这个位置，于是从所有元素中选择一个最小的。然后和第一个位置的...","link":"","photos":[],"count_time":{"symbolsCount":"2.7k","symbolsTime":"2 mins."},"categories":[{"name":"Algorithm","slug":"Algorithm","count":3,"path":"api/categories/Algorithm.json"},{"name":"C++","slug":"C","count":3,"path":"api/categories/C.json"}],"tags":[{"name":"算法","slug":"算法","count":3,"path":"api/tags/算法.json"},{"name":"C++","slug":"C","count":3,"path":"api/tags/C.json"}],"author":{"name":"Aurora","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},{"title":"MySQL联合索引和最左前缀原则理解一","uid":"6256a2c967d4226dbb5b05689bfb7d23","slug":"最左前缀","date":"2021-03-11T08:45:25.000Z","updated":"2023-10-18T01:53:17.946Z","comments":true,"path":"api/articles/最左前缀.json","keywords":"博客,后端,Java,算法,分布式,微服务,架构,业务开发,数据库,中间件,敏捷,管理,DDD,领域驱动设计,设计模式,搜索,消息队列","cover":[],"text":"如果给 user 表中的 username pwd 字段创建了复合索引那么使用以下SQL 都是可以命中索引: select username from user where username&#x3D;&#39;zhangsan&#39; and pwd &#x3D;&#39;a...","link":"","photos":[],"count_time":{"symbolsCount":"1.4k","symbolsTime":"1 mins."},"categories":[{"name":"MySQL","slug":"MySQL","count":1,"path":"api/categories/MySQL.json"},{"name":"数据库","slug":"数据库","count":1,"path":"api/categories/数据库.json"}],"tags":[{"name":"MySQL","slug":"MySQL","count":1,"path":"api/tags/MySQL.json"},{"name":"数据库调优","slug":"数据库调优","count":1,"path":"api/tags/数据库调优.json"}],"author":{"name":"Aurora","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},{"title":"动态代理","uid":"6b9ce45aac70d77e5b13dbe67f0c2d3a","slug":"动态代理","date":"2021-02-14T08:16:34.000Z","updated":"2023-10-18T01:53:17.945Z","comments":true,"path":"api/articles/动态代理.json","keywords":"博客,后端,Java,算法,分布式,微服务,架构,业务开发,数据库,中间件,敏捷,管理,DDD,领域驱动设计,设计模式,搜索,消息队列","cover":[],"text":"可以干什么 可以在运行时动态创建一个类，实现一个或多个接口，可以在不修改原有类的基础上动态为通过该类获取的对象添加方法、修改行为（增强） 动态代理是实现面向切面编程AOP的基础 AOP可以干什么？ 日志、性能监控、权限检查、数据库事务 AOP切面通过将切面逻辑和主体逻辑分离，使代...","link":"","photos":[],"count_time":{"symbolsCount":"3.7k","symbolsTime":"3 mins."},"categories":[{"name":"Java","slug":"Java","count":2,"path":"api/categories/Java.json"},{"name":"动态代理","slug":"动态代理","count":1,"path":"api/categories/动态代理.json"}],"tags":[{"name":"Java","slug":"Java","count":2,"path":"api/tags/Java.json"},{"name":"动态代理","slug":"动态代理","count":1,"path":"api/tags/动态代理.json"}],"author":{"name":"Aurora","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"选择排序","uid":"25abdf87b37439d6db828d8a717bff02","slug":"selection-sort","date":"2021-02-12T14:33:00.000Z","updated":"2023-10-18T01:53:17.945Z","comments":true,"path":"api/articles/selection-sort.json","keywords":"博客,后端,Java,算法,分布式,微服务,架构,业务开发,数据库,中间件,敏捷,管理,DDD,领域驱动设计,设计模式,搜索,消息队列","cover":[],"text":"排序过程假如对如下数组排序 我们打算从小到大排序 第一轮先找到数组中最小的，是1 然后将1和数组中第一个位置上的数交换，这样，1就是最终的位置了 第二轮那么1排好了，我们从剩下的数里面找最小的数，是2 我们将2和第二个位置上的数交换位置 此时，1和2都已经固定好了位置 第三轮再从...","link":"","photos":[],"count_time":{"symbolsCount":"6.9k","symbolsTime":"6 mins."},"categories":[{"name":"Algorithm","slug":"Algorithm","count":3,"path":"api/categories/Algorithm.json"},{"name":"C++","slug":"C","count":3,"path":"api/categories/C.json"}],"tags":[{"name":"算法","slug":"算法","count":3,"path":"api/tags/算法.json"},{"name":"C++","slug":"C","count":3,"path":"api/tags/C.json"}],"author":{"name":"Aurora","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"类加载机制","uid":"7749a2b5879f92c33b3cacbb2a610b9b","slug":"类加载机制","date":"2021-02-09T12:58:16.000Z","updated":"2023-10-18T01:53:17.947Z","comments":true,"path":"api/articles/类加载机制.json","keywords":"博客,后端,Java,算法,分布式,微服务,架构,业务开发,数据库,中间件,敏捷,管理,DDD,领域驱动设计,设计模式,搜索,消息队列","cover":[],"text":"类加载器可以做什么热部署不重启Java程序的情况下，动态替换类的实现 比如JSP、OSGI 应用的模块化和隔离不同的类加载器可以加载相同的类，但互相隔离、互不影响 比如： Tomcat在一个程序中管理多个Web应用，每个Web应用有自己的classloader OSGI和Java...","link":"","photos":[],"count_time":{"symbolsCount":"6.5k","symbolsTime":"6 mins."},"categories":[{"name":"Java","slug":"Java","count":2,"path":"api/categories/Java.json"},{"name":"ClassLoader","slug":"ClassLoader","count":1,"path":"api/categories/ClassLoader.json"}],"tags":[{"name":"Java","slug":"Java","count":2,"path":"api/tags/Java.json"},{"name":"类加载器","slug":"类加载器","count":1,"path":"api/tags/类加载器.json"}],"author":{"name":"Aurora","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"我应该写什么","uid":"a07ffd4c9309478a5fb940206e09d98f","slug":"我应该写什么","date":"2021-02-08T08:44:58.000Z","updated":"2023-10-18T01:53:17.946Z","comments":true,"path":"api/articles/我应该写什么.json","keywords":"博客,后端,Java,算法,分布式,微服务,架构,业务开发,数据库,中间件,敏捷,管理,DDD,领域驱动设计,设计模式,搜索,消息队列","cover":null,"text":"折腾了一天，重新把hexo博客建好了 不想再折腾了 打算要写的内容，计划用博客来做什么 记录学习过程，主要记录读书笔记、思维导图的总结、教程的总结（Java、分布式微服务、数据存储、算法、中间件源码架构设计） 记录排查问题的过程 记录生活中的想法（旅游、带娃、生活习惯养成、运动）...","link":"","photos":[],"count_time":{"symbolsCount":251,"symbolsTime":"1 mins."},"categories":[{"name":"Diary","slug":"Diary","count":1,"path":"api/categories/Diary.json"},{"name":"Life","slug":"Life","count":1,"path":"api/categories/Life.json"}],"tags":[{"name":"Diary","slug":"Diary","count":1,"path":"api/tags/Diary.json"},{"name":"Life","slug":"Life","count":1,"path":"api/tags/Life.json"}],"author":{"name":"Aurora","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}],"categories":9,"tags":14,"word_count":"27k","post_count":7}